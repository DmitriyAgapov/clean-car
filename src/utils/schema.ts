//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
//@ts-nocheck
import axios, { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import dayjs from 'dayjs';

export interface IClient {
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    accountsAllUsers(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous>;
    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsChangeEmail(data: ChangeEmailByOwner, id: number): Promise<ChangeEmailByOwner>;
    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsChangePassword(data: ChangePassword, id: number): Promise<ChangePassword>;
    accountsMyProfile(): Promise<OwnProfile>;
    accountsRegister(data: Register): Promise<Register>;
    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsProfileUpdate(data: UpdateUser, company_id: string, id: number): Promise<UpdateUser>;
    accountsUsersCreate(data: User, company_id: string): Promise<User>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    accountsUsersList(company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous2>;
    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsUsersRetrieve(company_id: string, id: number): Promise<User>;
    accountsAdminUploadUsers(): Promise<void>;
    accountsAdminUserCreate(data: UserCreate): Promise<UserCreate>;
    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsAdminUserDelete(id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsAdminUserRetrieve(id: number): Promise<UserRetrieve>;
    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    balanceTransactionsList(company_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous3>;
    bidPhotosCreate(data: BidPhoto, company_id: string): Promise<BidPhoto>;
    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    bidPhotosList(company_id: string, bid_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous4>;
    /**
     * @param id A unique integer value identifying this Фото заявки.
     */
    bidPhotosDelete(company_id: string, id: number): Promise<void>;
    /**
     * @param q (optional) Search
     * @param company__city (optional) company__city
     * @param status (optional) status
     * @param service_type (optional) service_type
     * @param start_date (optional) start_date
     * @param end_date (optional) end_date
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    bidsAllBidsList(q?: string | null | undefined, company__city?: string | null | undefined, status?: Status | null | undefined, service_type?: string | null | undefined, start_date?: string | null | undefined, end_date?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous5>;
    bidsCountAdmin(): Promise<void>;
    bidsBidPerformers(data: BidPerformer, company_id: string): Promise<BidPerformer>;
    bidsCountCustomer(company_id: string): Promise<void>;
    bidsCountPerformer(company_id: string): Promise<void>;
    bidsCreate(data: BidCreate, company_id: string): Promise<BidCreate>;
    /**
     * @param q (optional) Search
     * @param company__city (optional) company__city
     * @param status (optional) status
     * @param service_type (optional) service_type
     * @param start_date (optional) start_date
     * @param end_date (optional) end_date
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    bidsList(company_id: string, q?: string | null | undefined, company__city?: string | null | undefined, status?: Status2 | null | undefined, service_type?: string | null | undefined, start_date?: string | null | undefined, end_date?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous6>;
    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsCustomerComment(data: BidCustomerComment, company_id: string, id: number): Promise<BidCustomerComment>;
    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsExecutor(data: BidExecutor, company_id: string, id: number): Promise<BidExecutor>;
    /**
     * @param id A unique integer value identifying this Изменение заявки.
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    bidsHistory(company_id: string, id: number, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous7>;
    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsRetrieve(company_id: string, id: number): Promise<BidRetrieve>;
    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsService(data: BidService, company_id: string, id: number): Promise<BidService>;
    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsStatus(data: BidStatus, company_id: string, id: number): Promise<BidStatus>;
    carsCreate(data: CarCreateUpdate, company_id: string): Promise<CarCreateUpdate>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    carsList(company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous8>;
    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsDelete(company_id: string, id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsRetrieve(company_id: string, id: number): Promise<CarRetrieve>;
    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsUpdate(data: CarCreateUpdate, company_id: string, id: number): Promise<CarCreateUpdate>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    carsAdminList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous9>;
    carsAdminUploadCars(): Promise<void>;
    carsAdminCreate(data: CarCreateUpdate, company_id: string): Promise<CarCreateUpdate>;
    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsAdminUpdate(data: CarCreateUpdate, company_id: string, id: number): Promise<CarCreateUpdate>;
    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsAdminDelete(id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsAdminRetrieve(id: number): Promise<CarRetrieve>;
    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarBrands(name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous10>;
    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarBrandsCarModelsList(brand_id: string, name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous11>;
    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarBrandsWithModels(name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous12>;
    catalogCarModelsCreateWithExistBrand(data: CarModel): Promise<CarModel>;
    catalogCarModelsCreateWithNewBrand(data: CarModelNewBrand): Promise<CarModelNewBrand>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarModelsList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous13>;
    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsDelete(id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsRetrieve(id: number): Promise<CarModelRetrieve>;
    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsUpdateWithExistBrand(data: CarModel, id: number): Promise<CarModel>;
    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsUpdateWithNewBrand(data: CarModelNewBrand, id: number): Promise<CarModelNewBrand>;
    /**
     * @param name (optional) name
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCities(name?: string | null | undefined, is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous14>;
    catalogCitiesCreate(data: City): Promise<City>;
    /**
     * @param id A unique integer value identifying this Город.
     */
    catalogCitiesDelete(id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Город.
     */
    catalogCitiesRetrieve(id: number): Promise<City>;
    /**
     * @param id A unique integer value identifying this Город.
     */
    catalogCitiesUpdate(data: City, id: number): Promise<City>;
    /**
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogServices(is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous15>;
    catalogServicesOptionsCreate(data: ServiceOption): Promise<ServiceOption>;
    /**
     * @param id A unique integer value identifying this Опция услуги.
     */
    catalogServicesOptionsDelete(id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Опция услуги.
     */
    catalogServicesOptionsRetrieve(id: number): Promise<ServiceOption>;
    /**
     * @param id A unique integer value identifying this Опция услуги.
     */
    catalogServicesOptionsUpdate(data: ServiceOption, id: number): Promise<ServiceOption>;
    catalogServicesSubypesCreate(data: ServiceSubtypeCreate): Promise<ServiceSubtypeCreate>;
    /**
     * @param id A unique integer value identifying this Подтип услуги.
     */
    catalogServicesSubypesDelete(id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Подтип услуги.
     */
    catalogServicesSubypesRetrieve(id: number): Promise<ServiceSubtype>;
    /**
     * @param id A unique integer value identifying this Подтип услуги.
     */
    catalogServicesSubypesUpdate(data: ServiceSubtypeCreate, id: number): Promise<ServiceSubtypeCreate>;
    /**
     * @param id A unique integer value identifying this Тип услуги.
     */
    catalogServicesRetrieve(id: number): Promise<ServiceType>;
    /**
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogServicesSubypes(service_id: string, is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous16>;
    /**
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogServicesOptions(subype_id: string, is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous17>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    companiesAllCompaniesList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous18>;
    companiesCustomerCreate(data: CustomerCompany): Promise<CustomerCompany>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    companiesCustomerList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined): Promise<Anonymous19>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesCustomerRetrieve(id: number): Promise<GetCustomerCompany>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesCustomerUpdate(data: CustomerCompany, id: number): Promise<CustomerCompany>;
    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    companiesMyCompaniesList(ordering?: string | null | undefined, page?: number | null | undefined): Promise<Anonymous20>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    companiesOnlyBranchesList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous21>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    companiesOnlyCompaniesList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous22>;
    companiesPerformerCreate(data: PerformerCompany): Promise<PerformerCompany>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    companiesPerformerList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined): Promise<Anonymous23>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesPerformerRetrieve(id: number): Promise<GetPerformerCompany>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesPerformerUpdate(data: PerformerCompany, id: number): Promise<PerformerCompany>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesDelete(id: number): Promise<void>;
    customerBranchesCreate(data: CustomerBranch, company_id: string): Promise<CustomerBranch>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    customerBranchesList(company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined): Promise<Anonymous24>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    customerBranchesDelete(company_id: string, id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    customerBranchesRetrieve(company_id: string, id: number): Promise<GetCustomerBranch>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    customerBranchesUpdate(data: CustomerBranch, company_id: string, id: number): Promise<CustomerBranch>;
    limitsCreate(data: Limit, company_id: string): Promise<Limit>;
    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    limitsList(company_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous25>;
    /**
     * @param id A unique integer value identifying this Лимит.
     */
    limitsDelete(company_id: string, id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Лимит.
     */
    limitsRetrieve(company_id: string, id: number): Promise<Limit>;
    performerBranchesCreate(data: PerformerBranch, company_id: string): Promise<PerformerBranch>;
    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    performerBranchesList(company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined): Promise<Anonymous26>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    performerBranchesDelete(company_id: string, id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    performerBranchesRetrieve(company_id: string, id: number): Promise<GetPerformerBranch>;
    /**
     * @param id A unique integer value identifying this Компания.
     */
    performerBranchesUpdate(data: PerformerBranch, company_id: string, id: number): Promise<PerformerBranch>;
    permissionsGroupsCreate(data: GroupPermissions, company_id: string): Promise<GroupPermissions>;
    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    permissionsGroupsList(company_id: string, name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous27>;
    /**
     * @param id A unique integer value identifying this Группа разрешений.
     */
    permissionsGroupsDelete(company_id: string, id: number): Promise<void>;
    /**
     * @param id A unique integer value identifying this Группа разрешений.
     */
    permissionsGroupsRetrieve(company_id: string, id: number): Promise<GroupPermissions>;
    /**
     * @param id A unique integer value identifying this Группа разрешений.
     */
    permissionsGroupsUpdate(data: GroupPermissions, company_id: string, id: number): Promise<GroupPermissions>;
    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    priceAllCompaniesList(name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous28>;
    priceActiveEvacuation(company_id: string): Promise<GetEvacuationPrice>;
    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    priceActiveList(company_id: string, name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous29>;
    priceActiveTire(company_id: string): Promise<GetTirePrice>;
    priceActiveWash(company_id: string): Promise<GetWashPrice>;
    priceCreate(company_id: string): Promise<void>;
    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    priceHistory(company_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined): Promise<Anonymous30>;
    priceDoubling(company_id: string, id: string): Promise<void>;
    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceEvacuation(company_id: string, id: number): Promise<GetEvacuationPrice>;
    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceNewEvacuation(data: CreateNewPrice, company_id: string, id: number): Promise<CreateNewPrice>;
    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceNewTire(data: CreateNewPrice, company_id: string, id: number): Promise<CreateNewPrice>;
    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceNewWash(data: CreateNewPrice, company_id: string, id: number): Promise<CreateNewPrice>;
    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceTire(company_id: string, id: number): Promise<GetTirePrice>;
    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceWash(company_id: string, id: number): Promise<GetWashPrice>;
    token(data: CustomTokenObtainPair): Promise<CustomTokenObtainPair>;
    tokenRefresh(data: TokenRefresh): Promise<TokenRefresh>;
}

export class Client implements IClient {
    protected instance: AxiosInstance;
    protected baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance || axios.create();

        this.baseUrl = baseUrl ?? "https://dev.server.clean-car.net/api";

    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    accountsAllUsers(params:{q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous> {
        const { q, ordering, page, page_size, cancelToken } = params;
        let url_ = this.baseUrl + "/accounts/all_users/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsAllUsers(_response);
        });
    }

    protected processAccountsAllUsers(response: AxiosResponse): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous>(null as any);
    }

    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsChangeEmail(data: ChangeEmailByOwner, id: number, cancelToken?: CancelToken): Promise<ChangeEmailByOwner> {
        let url_ = this.baseUrl + "/accounts/change_email/{id}/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsChangeEmail(_response);
        });
    }

    protected processAccountsChangeEmail(response: AxiosResponse): Promise<ChangeEmailByOwner> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChangeEmailByOwner.fromJS(resultData200, _mappings);
            return Promise.resolve<ChangeEmailByOwner>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChangeEmailByOwner>(null as any);
    }

    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsChangePassword(data: ChangePassword, id: number, cancelToken?: CancelToken): Promise<ChangePassword> {
        let url_ = this.baseUrl + "/accounts/change_password/{id}/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsChangePassword(_response);
        });
    }

    protected processAccountsChangePassword(response: AxiosResponse): Promise<ChangePassword> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ChangePassword.fromJS(resultData200, _mappings);
            return Promise.resolve<ChangePassword>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ChangePassword>(null as any);
    }

    accountsMyProfile( cancelToken?: CancelToken): Promise<OwnProfile> {
        let url_ = this.baseUrl + "/accounts/my_profile/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsMyProfile(_response);
        });
    }

    protected processAccountsMyProfile(response: AxiosResponse): Promise<OwnProfile> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OwnProfile.fromJS(resultData200, _mappings);
            return Promise.resolve<OwnProfile>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OwnProfile>(null as any);
    }

    accountsRegister(data: Register, cancelToken?: CancelToken): Promise<Register> {
        let url_ = this.baseUrl + "/accounts/register/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsRegister(_response);
        });
    }

    protected processAccountsRegister(response: AxiosResponse): Promise<Register> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Register.fromJS(resultData201, _mappings);
            return Promise.resolve<Register>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Register>(null as any);
    }

    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsProfileUpdate(data: UpdateUser, company_id: string, id: number, cancelToken?: CancelToken): Promise<UpdateUser> {
        let url_ = this.baseUrl + "/accounts/{company_id}/profile/{id}/update/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsProfileUpdate(_response);
        });
    }

    protected processAccountsProfileUpdate(response: AxiosResponse): Promise<UpdateUser> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UpdateUser.fromJS(resultData200, _mappings);
            return Promise.resolve<UpdateUser>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UpdateUser>(null as any);
    }

    accountsUsersCreate(data: User, company_id: string, cancelToken?: CancelToken): Promise<User> {
        let url_ = this.baseUrl + "/accounts/{company_id}/users/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsUsersCreate(_response);
        });
    }

    protected processAccountsUsersCreate(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = User.fromJS(resultData201, _mappings);
            return Promise.resolve<User>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    accountsUsersList(params: {company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous2> {
        const { company_id, q, ordering, page, page_size, cancelToken } = params;
        let url_ = this.baseUrl + "/accounts/{company_id}/users/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsUsersList(_response);
        });
    }

    protected processAccountsUsersList(response: AxiosResponse): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous2.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous2>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous2>(null as any);
    }

    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsUsersRetrieve(company_id: string, id: number, cancelToken?: CancelToken): Promise<User> {
        let url_ = this.baseUrl + "/accounts/{company_id}/users/{id}/retrieve/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsUsersRetrieve(_response);
        });
    }

    protected processAccountsUsersRetrieve(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200, _mappings);
            return Promise.resolve<User>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    accountsAdminUploadUsers( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/accounts_admin/upload_users/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsAdminUploadUsers(_response);
        });
    }

    protected processAccountsAdminUploadUsers(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    accountsAdminUserCreate(data: UserCreate, cancelToken?: CancelToken): Promise<UserCreate> {
        let url_ = this.baseUrl + "/accounts_admin/user/create/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsAdminUserCreate(_response);
        });
    }

    protected processAccountsAdminUserCreate(response: AxiosResponse): Promise<UserCreate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = UserCreate.fromJS(resultData201, _mappings);
            return Promise.resolve<UserCreate>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserCreate>(null as any);
    }

    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsAdminUserDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/accounts_admin/user/{id}/delete/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsAdminUserDelete(_response);
        });
    }

    protected processAccountsAdminUserDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this пользователь.
     */
    accountsAdminUserRetrieve(id: number, cancelToken?: CancelToken): Promise<UserRetrieve> {
        let url_ = this.baseUrl + "/accounts_admin/user/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAccountsAdminUserRetrieve(_response);
        });
    }

    protected processAccountsAdminUserRetrieve(response: AxiosResponse): Promise<UserRetrieve> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserRetrieve.fromJS(resultData200, _mappings);
            return Promise.resolve<UserRetrieve>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserRetrieve>(null as any);
    }

    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    balanceTransactionsList(company_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/balance/{company_id}/transactions/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBalanceTransactionsList(_response);
        });
    }

    protected processBalanceTransactionsList(response: AxiosResponse): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous3.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous3>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous3>(null as any);
    }

    bidPhotosCreate(data: BidPhoto, company_id: string, cancelToken?: CancelToken): Promise<BidPhoto> {
        let url_ = this.baseUrl + "/bid_photos/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidPhotosCreate(_response);
        });
    }

    protected processBidPhotosCreate(response: AxiosResponse): Promise<BidPhoto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = BidPhoto.fromJS(resultData201, _mappings);
            return Promise.resolve<BidPhoto>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidPhoto>(null as any);
    }

    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    bidPhotosList(company_id: string, bid_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous4> {
        let url_ = this.baseUrl + "/bid_photos/{company_id}/{bid_id}/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (bid_id === undefined || bid_id === null)
            throw new Error("The parameter 'bid_id' must be defined.");
        url_ = url_.replace("{bid_id}", encodeURIComponent("" + bid_id));
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidPhotosList(_response);
        });
    }

    protected processBidPhotosList(response: AxiosResponse): Promise<Anonymous4> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous4.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous4>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous4>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Фото заявки.
     */
    bidPhotosDelete(company_id: string, id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/bid_photos/{company_id}/{id}/delete/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidPhotosDelete(_response);
        });
    }

    protected processBidPhotosDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param params
     */
    bidsAllBidsList(params: {q?: string | null | undefined, company__city?: string | null | undefined, status?: Status | null | undefined, service_type?: string | null | undefined, start_date?: string | null | undefined, end_date?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous5> {
        const { q, company__city, status, service_type, start_date, end_date, ordering, page, page_size, cancelToken } = params;
        let url_ = this.baseUrl + "/bids/all_bids/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (company__city !== undefined && company__city !== null)
            url_ += "company__city=" + encodeURIComponent("" + company__city) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (service_type !== undefined && service_type !== null)
            url_ += "service_type=" + encodeURIComponent("" + service_type) + "&";
        if (start_date !== undefined && start_date !== null)
            url_ += "start_date=" + encodeURIComponent("" + start_date) + "&";
        if (end_date !== undefined && end_date !== null)
            url_ += "end_date=" + encodeURIComponent("" + end_date) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsAllBidsList(_response);
        });
    }

    protected processBidsAllBidsList(response: AxiosResponse): Promise<Anonymous5> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous5.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous5>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous5>(null as any);
    }

    bidsCountAdmin( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/bids/count/admin/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsCountAdmin(_response);
        });
    }

    protected processBidsCountAdmin(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    bidsBidPerformers(data: BidPerformer, company_id: string, cancelToken?: CancelToken): Promise<BidPerformer> {
        let url_ = this.baseUrl + "/bids/{company_id}/bid_performers/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsBidPerformers(_response);
        });
    }

    protected processBidsBidPerformers(response: AxiosResponse): Promise<BidPerformer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = BidPerformer.fromJS(resultData201, _mappings);
            return Promise.resolve<BidPerformer>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidPerformer>(null as any);
    }

    bidsCountCustomer(company_id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/bids/{company_id}/count/customer/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsCountCustomer(_response);
        });
    }

    protected processBidsCountCustomer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    bidsCountPerformer(company_id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/bids/{company_id}/count/performer/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsCountPerformer(_response);
        });
    }

    protected processBidsCountPerformer(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    bidsCreate(data: BidCreate, company_id: string, cancelToken?: CancelToken): Promise<BidCreate> {
        let url_ = this.baseUrl + "/bids/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsCreate(_response);
        });
    }

    protected processBidsCreate(response: AxiosResponse): Promise<BidCreate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = BidCreate.fromJS(resultData201, _mappings);
            return Promise.resolve<BidCreate>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidCreate>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param company__city (optional) company__city
     * @param status (optional) status
     * @param service_type (optional) service_type
     * @param start_date (optional) start_date
     * @param end_date (optional) end_date
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    bidsList(params: {company_id: string, q?: string | null | undefined, company__city?: string | null | undefined, status?: Status2 | null | undefined, service_type?: string | null | undefined, start_date?: string | null | undefined, end_date?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous6> {
        const {company_id, q, company__city, status, page, ordering, page_size, cancelToken, service_type, end_date, start_date} = params
        let url_ = this.baseUrl + "/bids/{company_id}/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (company__city !== undefined && company__city !== null)
            url_ += "company__city=" + encodeURIComponent("" + company__city) + "&";
        if (status !== undefined && status !== null)
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (service_type !== undefined && service_type !== null)
            url_ += "service_type=" + encodeURIComponent("" + service_type) + "&";
        if (start_date !== undefined && start_date !== null)
            url_ += "start_date=" + encodeURIComponent("" + start_date) + "&";
        if (end_date !== undefined && end_date !== null)
            url_ += "end_date=" + encodeURIComponent("" + end_date) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsList(_response);
        });
    }

    protected processBidsList(response: AxiosResponse): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous6.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous6>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous6>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsCustomerComment(data: BidCustomerComment, company_id: string, id: number, cancelToken?: CancelToken): Promise<BidCustomerComment> {
        let url_ = this.baseUrl + "/bids/{company_id}/{id}/customer_comment/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsCustomerComment(_response);
        });
    }

    protected processBidsCustomerComment(response: AxiosResponse): Promise<BidCustomerComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BidCustomerComment.fromJS(resultData200, _mappings);
            return Promise.resolve<BidCustomerComment>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidCustomerComment>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsExecutor(data: BidExecutor, company_id: string, id: number, cancelToken?: CancelToken): Promise<BidExecutor> {
        let url_ = this.baseUrl + "/bids/{company_id}/{id}/executor/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsExecutor(_response);
        });
    }

    protected processBidsExecutor(response: AxiosResponse): Promise<BidExecutor> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BidExecutor.fromJS(resultData200, _mappings);
            return Promise.resolve<BidExecutor>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidExecutor>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Изменение заявки.
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    bidsHistory(params: {company_id: string, id: number, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous7> {
        const {company_id, id, ordering, page, page_size, cancelToken} = params
        let url_ = this.baseUrl + "/bids/{company_id}/{id}/history/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsHistory(_response);
        });
    }

    protected processBidsHistory(response: AxiosResponse): Promise<Anonymous7> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous7.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous7>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous7>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsRetrieve(company_id: string, id: number, cancelToken?: CancelToken): Promise<BidRetrieve> {
        let url_ = this.baseUrl + "/bids/{company_id}/{id}/retrieve/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsRetrieve(_response);
        });
    }

    protected processBidsRetrieve(response: AxiosResponse): Promise<BidRetrieve> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BidRetrieve.fromJS(resultData200, _mappings);
            return Promise.resolve<BidRetrieve>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidRetrieve>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsService(data: BidService, company_id: string, id: number, cancelToken?: CancelToken): Promise<BidService> {
        let url_ = this.baseUrl + "/bids/{company_id}/{id}/service/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsService(_response);
        });
    }

    protected processBidsService(response: AxiosResponse): Promise<BidService> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BidService.fromJS(resultData200, _mappings);
            return Promise.resolve<BidService>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidService>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Заявка.
     */
    bidsStatus(data: BidStatus, company_id: string, id: number, cancelToken?: CancelToken): Promise<BidStatus> {
        let url_ = this.baseUrl + "/bids/{company_id}/{id}/status/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processBidsStatus(_response);
        });
    }

    protected processBidsStatus(response: AxiosResponse): Promise<BidStatus> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BidStatus.fromJS(resultData200, _mappings);
            return Promise.resolve<BidStatus>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BidStatus>(null as any);
    }

    carsCreate(data: CarCreateUpdate, company_id: string, cancelToken?: CancelToken): Promise<CarCreateUpdate> {
        let url_ = this.baseUrl + "/cars/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsCreate(_response);
        });
    }

    protected processCarsCreate(response: AxiosResponse): Promise<CarCreateUpdate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CarCreateUpdate.fromJS(resultData201, _mappings);
            return Promise.resolve<CarCreateUpdate>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarCreateUpdate>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    carsList(params: {company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous8> {
        const { company_id, q, ordering, page, page_size, cancelToken } = params;
        let url_ = this.baseUrl + "/cars/{company_id}/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsList(_response);
        });
    }

    protected processCarsList(response: AxiosResponse): Promise<Anonymous8> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous8.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous8>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous8>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsDelete(company_id: string, id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/cars/{company_id}/{id}/delete/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsDelete(_response);
        });
    }

    protected processCarsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsRetrieve(params: {company_id: string, id: number, cancelToken?: CancelToken}): Promise<CarRetrieve> {
        const { company_id, id, cancelToken } = params;
        let url_ = this.baseUrl + "/cars/{company_id}/{id}/retrieve/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsRetrieve(_response);
        });
    }

    protected processCarsRetrieve(response: AxiosResponse): Promise<CarRetrieve> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CarRetrieve.fromJS(resultData200, _mappings);
            return Promise.resolve<CarRetrieve>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarRetrieve>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsUpdate(data: CarCreateUpdate, company_id: string, id: number, cancelToken?: CancelToken): Promise<CarCreateUpdate> {
        let url_ = this.baseUrl + "/cars/{company_id}/{id}/update/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsUpdate(_response);
        });
    }

    protected processCarsUpdate(response: AxiosResponse): Promise<CarCreateUpdate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CarCreateUpdate.fromJS(resultData200, _mappings);
            return Promise.resolve<CarCreateUpdate>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarCreateUpdate>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    carsAdminList(params: {q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous9> {
        const { q, ordering, page, page_size, cancelToken } = params;
        let url_ = this.baseUrl + "/cars_admin/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsAdminList(_response);
        });
    }

    protected processCarsAdminList(response: AxiosResponse): Promise<Anonymous9> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous9.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous9>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous9>(null as any);
    }

    carsAdminUploadCars( cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/cars_admin/upload_cars/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsAdminUploadCars(_response);
        });
    }

    protected processCarsAdminUploadCars(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    carsAdminCreate(data: CarCreateUpdate, company_id: string, cancelToken?: CancelToken): Promise<CarCreateUpdate> {
        let url_ = this.baseUrl + "/cars_admin/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsAdminCreate(_response);
        });
    }

    protected processCarsAdminCreate(response: AxiosResponse): Promise<CarCreateUpdate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CarCreateUpdate.fromJS(resultData201, _mappings);
            return Promise.resolve<CarCreateUpdate>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarCreateUpdate>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsAdminUpdate(data: CarCreateUpdate, company_id: string, id: number, cancelToken?: CancelToken): Promise<CarCreateUpdate> {
        let url_ = this.baseUrl + "/cars_admin/{company_id}/{id}/update/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsAdminUpdate(_response);
        });
    }

    protected processCarsAdminUpdate(response: AxiosResponse): Promise<CarCreateUpdate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CarCreateUpdate.fromJS(resultData200, _mappings);
            return Promise.resolve<CarCreateUpdate>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarCreateUpdate>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsAdminDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/cars_admin/{id}/delete/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsAdminDelete(_response);
        });
    }

    protected processCarsAdminDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Автомобиль.
     */
    carsAdminRetrieve(id: number, cancelToken?: CancelToken): Promise<CarRetrieve> {
        let url_ = this.baseUrl + "/cars_admin/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCarsAdminRetrieve(_response);
        });
    }

    protected processCarsAdminRetrieve(response: AxiosResponse): Promise<CarRetrieve> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CarRetrieve.fromJS(resultData200, _mappings);
            return Promise.resolve<CarRetrieve>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarRetrieve>(null as any);
    }

    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarBrands(name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous10> {
        let url_ = this.baseUrl + "/catalog/car_brands/?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarBrands(_response);
        });
    }

    protected processCatalogCarBrands(response: AxiosResponse): Promise<Anonymous10> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous10.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous10>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous10>(null as any);
    }

    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarBrandsCarModelsList(brand_id: string, name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous11> {
        let url_ = this.baseUrl + "/catalog/car_brands/{brand_id}/car_models/list/?";
        if (brand_id === undefined || brand_id === null)
            throw new Error("The parameter 'brand_id' must be defined.");
        url_ = url_.replace("{brand_id}", encodeURIComponent("" + brand_id));
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarBrandsCarModelsList(_response);
        });
    }

    protected processCatalogCarBrandsCarModelsList(response: AxiosResponse): Promise<Anonymous11> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous11.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous11>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous11>(null as any);
    }

    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarBrandsWithModels(name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous12> {
        let url_ = this.baseUrl + "/catalog/car_brands_with_models/?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarBrandsWithModels(_response);
        });
    }

    protected processCatalogCarBrandsWithModels(response: AxiosResponse): Promise<Anonymous12> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous12.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous12>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous12>(null as any);
    }

    catalogCarModelsCreateWithExistBrand(data: CarModel, cancelToken?: CancelToken): Promise<CarModel> {
        let url_ = this.baseUrl + "/catalog/car_models/create_with_exist_brand/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarModelsCreateWithExistBrand(_response);
        });
    }

    protected processCatalogCarModelsCreateWithExistBrand(response: AxiosResponse): Promise<CarModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CarModel.fromJS(resultData201, _mappings);
            return Promise.resolve<CarModel>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarModel>(null as any);
    }

    catalogCarModelsCreateWithNewBrand(data: CarModelNewBrand, cancelToken?: CancelToken): Promise<CarModelNewBrand> {
        let url_ = this.baseUrl + "/catalog/car_models/create_with_new_brand/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarModelsCreateWithNewBrand(_response);
        });
    }

    protected processCatalogCarModelsCreateWithNewBrand(response: AxiosResponse): Promise<CarModelNewBrand> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CarModelNewBrand.fromJS(resultData201, _mappings);
            return Promise.resolve<CarModelNewBrand>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarModelNewBrand>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCarModelsList(params: {q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous13> {
        const { q, ordering, page, page_size, cancelToken } = params;
        let url_ = this.baseUrl + "/catalog/car_models/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarModelsList(_response);
        });
    }

    protected processCatalogCarModelsList(response: AxiosResponse): Promise<Anonymous13> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous13.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous13>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous13>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/catalog/car_models/{id}/delete/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarModelsDelete(_response);
        });
    }

    protected processCatalogCarModelsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsRetrieve(id: number, cancelToken?: CancelToken): Promise<CarModelRetrieve> {
        let url_ = this.baseUrl + "/catalog/car_models/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarModelsRetrieve(_response);
        });
    }

    protected processCatalogCarModelsRetrieve(response: AxiosResponse): Promise<CarModelRetrieve> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CarModelRetrieve.fromJS(resultData200, _mappings);
            return Promise.resolve<CarModelRetrieve>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarModelRetrieve>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsUpdateWithExistBrand(data: CarModel, id: number, cancelToken?: CancelToken): Promise<CarModel> {
        let url_ = this.baseUrl + "/catalog/car_models/{id}/update_with_exist_brand/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarModelsUpdateWithExistBrand(_response);
        });
    }

    protected processCatalogCarModelsUpdateWithExistBrand(response: AxiosResponse): Promise<CarModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CarModel.fromJS(resultData200, _mappings);
            return Promise.resolve<CarModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarModel>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Модель автомобиля.
     */
    catalogCarModelsUpdateWithNewBrand(data: CarModelNewBrand, id: number, cancelToken?: CancelToken): Promise<CarModelNewBrand> {
        let url_ = this.baseUrl + "/catalog/car_models/{id}/update_with_new_brand/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCarModelsUpdateWithNewBrand(_response);
        });
    }

    protected processCatalogCarModelsUpdateWithNewBrand(response: AxiosResponse): Promise<CarModelNewBrand> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CarModelNewBrand.fromJS(resultData200, _mappings);
            return Promise.resolve<CarModelNewBrand>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CarModelNewBrand>(null as any);
    }

    /**
     * @param name (optional) name
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogCities(name?: string | null | undefined, is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous14> {
        let url_ = this.baseUrl + "/catalog/cities/?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (is_active !== undefined && is_active !== null)
            url_ += "is_active=" + encodeURIComponent("" + is_active) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCities(_response);
        });
    }

    protected processCatalogCities(response: AxiosResponse): Promise<Anonymous14> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous14.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous14>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous14>(null as any);
    }

    catalogCitiesCreate(data: City, cancelToken?: CancelToken): Promise<City> {
        let url_ = this.baseUrl + "/catalog/cities/create/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCitiesCreate(_response);
        });
    }

    protected processCatalogCitiesCreate(response: AxiosResponse): Promise<City> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = City.fromJS(resultData201, _mappings);
            return Promise.resolve<City>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<City>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Город.
     */
    catalogCitiesDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/catalog/cities/{id}/delete/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCitiesDelete(_response);
        });
    }

    protected processCatalogCitiesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Город.
     */
    catalogCitiesRetrieve(id: number, cancelToken?: CancelToken): Promise<City> {
        let url_ = this.baseUrl + "/catalog/cities/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCitiesRetrieve(_response);
        });
    }

    protected processCatalogCitiesRetrieve(response: AxiosResponse): Promise<City> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = City.fromJS(resultData200, _mappings);
            return Promise.resolve<City>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<City>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Город.
     */
    catalogCitiesUpdate(data: City, id: number, cancelToken?: CancelToken): Promise<City> {
        let url_ = this.baseUrl + "/catalog/cities/{id}/update/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogCitiesUpdate(_response);
        });
    }

    protected processCatalogCitiesUpdate(response: AxiosResponse): Promise<City> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = City.fromJS(resultData200, _mappings);
            return Promise.resolve<City>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<City>(null as any);
    }

    /**
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogServices(is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous15> {
        let url_ = this.baseUrl + "/catalog/services/?";
        if (is_active !== undefined && is_active !== null)
            url_ += "is_active=" + encodeURIComponent("" + is_active) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServices(_response);
        });
    }

    protected processCatalogServices(response: AxiosResponse): Promise<Anonymous15> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous15.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous15>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous15>(null as any);
    }

    catalogServicesOptionsCreate(data: ServiceOption, cancelToken?: CancelToken): Promise<ServiceOption> {
        let url_ = this.baseUrl + "/catalog/services/options/create/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesOptionsCreate(_response);
        });
    }

    protected processCatalogServicesOptionsCreate(response: AxiosResponse): Promise<ServiceOption> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = ServiceOption.fromJS(resultData201, _mappings);
            return Promise.resolve<ServiceOption>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceOption>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Опция услуги.
     */
    catalogServicesOptionsDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/catalog/services/options/{id}/delete/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesOptionsDelete(_response);
        });
    }

    protected processCatalogServicesOptionsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Опция услуги.
     */
    catalogServicesOptionsRetrieve(id: number, cancelToken?: CancelToken): Promise<ServiceOption> {
        let url_ = this.baseUrl + "/catalog/services/options/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesOptionsRetrieve(_response);
        });
    }

    protected processCatalogServicesOptionsRetrieve(response: AxiosResponse): Promise<ServiceOption> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceOption.fromJS(resultData200, _mappings);
            return Promise.resolve<ServiceOption>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceOption>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Опция услуги.
     */
    catalogServicesOptionsUpdate(data: ServiceOption, id: number, cancelToken?: CancelToken): Promise<ServiceOption> {
        let url_ = this.baseUrl + "/catalog/services/options/{id}/update/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesOptionsUpdate(_response);
        });
    }

    protected processCatalogServicesOptionsUpdate(response: AxiosResponse): Promise<ServiceOption> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceOption.fromJS(resultData200, _mappings);
            return Promise.resolve<ServiceOption>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceOption>(null as any);
    }

    catalogServicesSubypesCreate(data: ServiceSubtypeCreate, cancelToken?: CancelToken): Promise<ServiceSubtypeCreate> {
        let url_ = this.baseUrl + "/catalog/services/subypes/create/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesSubypesCreate(_response);
        });
    }

    protected processCatalogServicesSubypesCreate(response: AxiosResponse): Promise<ServiceSubtypeCreate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = ServiceSubtypeCreate.fromJS(resultData201, _mappings);
            return Promise.resolve<ServiceSubtypeCreate>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceSubtypeCreate>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Подтип услуги.
     */
    catalogServicesSubypesDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/catalog/services/subypes/{id}/delete/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesSubypesDelete(_response);
        });
    }

    protected processCatalogServicesSubypesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Подтип услуги.
     */
    catalogServicesSubypesRetrieve(id: number, cancelToken?: CancelToken): Promise<ServiceSubtype> {
        let url_ = this.baseUrl + "/catalog/services/subypes/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesSubypesRetrieve(_response);
        });
    }

    protected processCatalogServicesSubypesRetrieve(response: AxiosResponse): Promise<ServiceSubtype> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceSubtype.fromJS(resultData200, _mappings);
            return Promise.resolve<ServiceSubtype>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceSubtype>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Подтип услуги.
     */
    catalogServicesSubypesUpdate(data: ServiceSubtypeCreate, id: number, cancelToken?: CancelToken): Promise<ServiceSubtypeCreate> {
        let url_ = this.baseUrl + "/catalog/services/subypes/{id}/update/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesSubypesUpdate(_response);
        });
    }

    protected processCatalogServicesSubypesUpdate(response: AxiosResponse): Promise<ServiceSubtypeCreate> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceSubtypeCreate.fromJS(resultData200, _mappings);
            return Promise.resolve<ServiceSubtypeCreate>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceSubtypeCreate>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Тип услуги.
     */
    catalogServicesRetrieve(id: number, cancelToken?: CancelToken): Promise<ServiceType> {
        let url_ = this.baseUrl + "/catalog/services/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesRetrieve(_response);
        });
    }

    protected processCatalogServicesRetrieve(response: AxiosResponse): Promise<ServiceType> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ServiceType.fromJS(resultData200, _mappings);
            return Promise.resolve<ServiceType>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ServiceType>(null as any);
    }

    /**
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogServicesSubypes(service_id: string, is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous16> {
        let url_ = this.baseUrl + "/catalog/services/{service_id}/subypes/?";
        if (service_id === undefined || service_id === null)
            throw new Error("The parameter 'service_id' must be defined.");
        url_ = url_.replace("{service_id}", encodeURIComponent("" + service_id));
        if (is_active !== undefined && is_active !== null)
            url_ += "is_active=" + encodeURIComponent("" + is_active) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesSubypes(_response);
        });
    }

    protected processCatalogServicesSubypes(response: AxiosResponse): Promise<Anonymous16> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous16.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous16>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous16>(null as any);
    }

    /**
     * @param is_active (optional) is_active
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    catalogServicesOptions(subype_id: string, is_active?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous17> {
        let url_ = this.baseUrl + "/catalog/services/{subype_id}/options/?";
        if (subype_id === undefined || subype_id === null)
            throw new Error("The parameter 'subype_id' must be defined.");
        url_ = url_.replace("{subype_id}", encodeURIComponent("" + subype_id));
        if (is_active !== undefined && is_active !== null)
            url_ += "is_active=" + encodeURIComponent("" + is_active) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogServicesOptions(_response);
        });
    }

    protected processCatalogServicesOptions(response: AxiosResponse): Promise<Anonymous17> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous17.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous17>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous17>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    companiesAllCompaniesList(params: {q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous18> {
        const {q, ordering, page, page_size, cancelToken} = params;
        let url_ = this.baseUrl + "/companies/all_companies/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesAllCompaniesList(_response);
        });
    }

    protected processCompaniesAllCompaniesList(response: AxiosResponse): Promise<Anonymous18> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous18.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous18>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous18>(null as any);
    }

    companiesCustomerCreate(data: CustomerCompany, cancelToken?: CancelToken): Promise<CustomerCompany> {
        let url_ = this.baseUrl + "/companies/customer/create/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesCustomerCreate(_response);
        });
    }

    protected processCompaniesCustomerCreate(response: AxiosResponse): Promise<CustomerCompany> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CustomerCompany.fromJS(resultData201, _mappings);
            return Promise.resolve<CustomerCompany>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerCompany>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    companiesCustomerList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous19> {
        let url_ = this.baseUrl + "/companies/customer/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesCustomerList(_response);
        });
    }

    protected processCompaniesCustomerList(response: AxiosResponse): Promise<Anonymous19> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous19.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous19>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous19>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesCustomerRetrieve(id: number, cancelToken?: CancelToken): Promise<GetCustomerCompany> {
        let url_ = this.baseUrl + "/companies/customer/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesCustomerRetrieve(_response);
        });
    }

    protected processCompaniesCustomerRetrieve(response: AxiosResponse): Promise<GetCustomerCompany> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCustomerCompany.fromJS(resultData200, _mappings);
            return Promise.resolve<GetCustomerCompany>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCustomerCompany>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesCustomerUpdate(data: CustomerCompany, id: number, cancelToken?: CancelToken): Promise<CustomerCompany> {
        let url_ = this.baseUrl + "/companies/customer/{id}/update/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesCustomerUpdate(_response);
        });
    }

    protected processCompaniesCustomerUpdate(response: AxiosResponse): Promise<CustomerCompany> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerCompany.fromJS(resultData200, _mappings);
            return Promise.resolve<CustomerCompany>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerCompany>(null as any);
    }

    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    companiesMyCompaniesList(ordering?: string | null | undefined, page?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous20> {
        let url_ = this.baseUrl + "/companies/my_companies/list/?";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesMyCompaniesList(_response);
        });
    }

    protected processCompaniesMyCompaniesList(response: AxiosResponse): Promise<Anonymous20> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous20.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous20>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous20>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    companiesOnlyBranchesList(params: {q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous21> {
        const {q, ordering, page, page_size, cancelToken} = params;
        let url_ = this.baseUrl + "/companies/only_branches/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesOnlyBranchesList(_response);
        });
    }

    protected processCompaniesOnlyBranchesList(response: AxiosResponse): Promise<Anonymous21> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous21.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous21>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous21>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    companiesOnlyCompaniesList(params: {q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous22> {
        const {q, ordering, page, page_size, cancelToken} = params;
        let url_ = this.baseUrl + "/companies/only_companies/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesOnlyCompaniesList(_response);
        });
    }

    protected processCompaniesOnlyCompaniesList(response: AxiosResponse): Promise<Anonymous22> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous22.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous22>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous22>(null as any);
    }

    companiesPerformerCreate(data: PerformerCompany, cancelToken?: CancelToken): Promise<PerformerCompany> {
        let url_ = this.baseUrl + "/companies/performer/create/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesPerformerCreate(_response);
        });
    }

    protected processCompaniesPerformerCreate(response: AxiosResponse): Promise<PerformerCompany> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = PerformerCompany.fromJS(resultData201, _mappings);
            return Promise.resolve<PerformerCompany>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PerformerCompany>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    companiesPerformerList(q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous23> {
        let url_ = this.baseUrl + "/companies/performer/list/?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesPerformerList(_response);
        });
    }

    protected processCompaniesPerformerList(response: AxiosResponse): Promise<Anonymous23> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous23.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous23>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous23>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesPerformerRetrieve(id: number, cancelToken?: CancelToken): Promise<GetPerformerCompany> {
        let url_ = this.baseUrl + "/companies/performer/{id}/retrieve/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesPerformerRetrieve(_response);
        });
    }

    protected processCompaniesPerformerRetrieve(response: AxiosResponse): Promise<GetPerformerCompany> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetPerformerCompany.fromJS(resultData200, _mappings);
            return Promise.resolve<GetPerformerCompany>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPerformerCompany>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesPerformerUpdate(data: PerformerCompany, id: number, cancelToken?: CancelToken): Promise<PerformerCompany> {
        let url_ = this.baseUrl + "/companies/performer/{id}/update/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesPerformerUpdate(_response);
        });
    }

    protected processCompaniesPerformerUpdate(response: AxiosResponse): Promise<PerformerCompany> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PerformerCompany.fromJS(resultData200, _mappings);
            return Promise.resolve<PerformerCompany>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PerformerCompany>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    companiesDelete(id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/companies/{id}/delete/";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompaniesDelete(_response);
        });
    }

    protected processCompaniesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    customerBranchesCreate(data: CustomerBranch, company_id: string, cancelToken?: CancelToken): Promise<CustomerBranch> {
        let url_ = this.baseUrl + "/customer_branches/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerBranchesCreate(_response);
        });
    }

    protected processCustomerBranchesCreate(response: AxiosResponse): Promise<CustomerBranch> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CustomerBranch.fromJS(resultData201, _mappings);
            return Promise.resolve<CustomerBranch>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerBranch>(null as any);
    }

    /**
     * @param params
     */
    customerBranchesList(params: {company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous24> {
        const {company_id, q, ordering, page, cancelToken} = params

        let url_ = this.baseUrl + "/customer_branches/{company_id}/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerBranchesList(_response);
        });
    }

    protected processCustomerBranchesList(response: AxiosResponse): Promise<Anonymous24> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous24.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous24>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous24>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    customerBranchesDelete(company_id: string, id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/customer_branches/{company_id}/{id}/delete/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerBranchesDelete(_response);
        });
    }

    protected processCustomerBranchesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    customerBranchesRetrieve(company_id: string, id: number, cancelToken?: CancelToken): Promise<GetCustomerBranch> {
        let url_ = this.baseUrl + "/customer_branches/{company_id}/{id}/retrieve/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerBranchesRetrieve(_response);
        });
    }

    protected processCustomerBranchesRetrieve(response: AxiosResponse): Promise<GetCustomerBranch> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCustomerBranch.fromJS(resultData200, _mappings);
            return Promise.resolve<GetCustomerBranch>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCustomerBranch>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    customerBranchesUpdate(data: CustomerBranch, company_id: string, id: number, cancelToken?: CancelToken): Promise<CustomerBranch> {
        let url_ = this.baseUrl + "/customer_branches/{company_id}/{id}/update/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCustomerBranchesUpdate(_response);
        });
    }

    protected processCustomerBranchesUpdate(response: AxiosResponse): Promise<CustomerBranch> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CustomerBranch.fromJS(resultData200, _mappings);
            return Promise.resolve<CustomerBranch>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomerBranch>(null as any);
    }

    limitsCreate(data: Limit, company_id: string, cancelToken?: CancelToken): Promise<Limit> {
        let url_ = this.baseUrl + "/limits/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLimitsCreate(_response);
        });
    }

    protected processLimitsCreate(response: AxiosResponse): Promise<Limit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = Limit.fromJS(resultData201, _mappings);
            return Promise.resolve<Limit>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Limit>(null as any);
    }

    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    limitsList(company_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous25> {
        let url_ = this.baseUrl + "/limits/{company_id}/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLimitsList(_response);
        });
    }

    protected processLimitsList(response: AxiosResponse): Promise<Anonymous25> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous25.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous25>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous25>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Лимит.
     */
    limitsDelete(company_id: string, id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/limits/{company_id}/{id}/delete/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLimitsDelete(_response);
        });
    }

    protected processLimitsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Лимит.
     */
    limitsRetrieve(company_id: string, id: number, cancelToken?: CancelToken): Promise<Limit> {
        let url_ = this.baseUrl + "/limits/{company_id}/{id}/retrieve/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLimitsRetrieve(_response);
        });
    }

    protected processLimitsRetrieve(response: AxiosResponse): Promise<Limit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Limit.fromJS(resultData200, _mappings);
            return Promise.resolve<Limit>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Limit>(null as any);
    }

    performerBranchesCreate(data: PerformerBranch, company_id: string, cancelToken?: CancelToken): Promise<PerformerBranch> {
        let url_ = this.baseUrl + "/performer_branches/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPerformerBranchesCreate(_response);
        });
    }

    protected processPerformerBranchesCreate(response: AxiosResponse): Promise<PerformerBranch> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = PerformerBranch.fromJS(resultData201, _mappings);
            return Promise.resolve<PerformerBranch>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PerformerBranch>(null as any);
    }

    /**
     * @param q (optional) Search
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     */
    performerBranchesList(params: {company_id: string, q?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, cancelToken?: CancelToken}): Promise<Anonymous26> {
        const {company_id, q, ordering, page, cancelToken} = params

        let url_ = this.baseUrl + "/performer_branches/{company_id}/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPerformerBranchesList(_response);
        });
    }

    protected processPerformerBranchesList(response: AxiosResponse): Promise<Anonymous26> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous26.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous26>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous26>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    performerBranchesDelete(company_id: string, id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/performer_branches/{company_id}/{id}/delete/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPerformerBranchesDelete(_response);
        });
    }

    protected processPerformerBranchesDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    performerBranchesRetrieve(company_id: string, id: number, cancelToken?: CancelToken): Promise<GetPerformerBranch> {
        let url_ = this.baseUrl + "/performer_branches/{company_id}/{id}/retrieve/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPerformerBranchesRetrieve(_response);
        });
    }

    protected processPerformerBranchesRetrieve(response: AxiosResponse): Promise<GetPerformerBranch> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetPerformerBranch.fromJS(resultData200, _mappings);
            return Promise.resolve<GetPerformerBranch>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetPerformerBranch>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Компания.
     */
    performerBranchesUpdate(data: PerformerBranch, company_id: string, id: number, cancelToken?: CancelToken): Promise<PerformerBranch> {
        let url_ = this.baseUrl + "/performer_branches/{company_id}/{id}/update/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPerformerBranchesUpdate(_response);
        });
    }

    protected processPerformerBranchesUpdate(response: AxiosResponse): Promise<PerformerBranch> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PerformerBranch.fromJS(resultData200, _mappings);
            return Promise.resolve<PerformerBranch>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PerformerBranch>(null as any);
    }

    permissionsGroupsCreate(data: GroupPermissions, company_id: string, cancelToken?: CancelToken): Promise<GroupPermissions> {
        let url_ = this.baseUrl + "/permissions/{company_id}/groups/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGroupsCreate(_response);
        });
    }

    protected processPermissionsGroupsCreate(response: AxiosResponse): Promise<GroupPermissions> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = GroupPermissions.fromJS(resultData201, _mappings);
            return Promise.resolve<GroupPermissions>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupPermissions>(null as any);
    }

    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    permissionsGroupsList(company_id: string, name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous27> {
        let url_ = this.baseUrl + "/permissions/{company_id}/groups/list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGroupsList(_response);
        });
    }

    protected processPermissionsGroupsList(response: AxiosResponse): Promise<Anonymous27> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous27.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous27>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous27>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Группа разрешений.
     */
    permissionsGroupsDelete(company_id: string, id: number, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/permissions/{company_id}/groups/{id}/delete/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGroupsDelete(_response);
        });
    }

    protected processPermissionsGroupsDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 204) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Группа разрешений.
     */
    permissionsGroupsRetrieve(company_id: string, id: number, cancelToken?: CancelToken): Promise<GroupPermissions> {
        let url_ = this.baseUrl + "/permissions/{company_id}/groups/{id}/retrieve/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGroupsRetrieve(_response);
        });
    }

    protected processPermissionsGroupsRetrieve(response: AxiosResponse): Promise<GroupPermissions> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupPermissions.fromJS(resultData200, _mappings);
            return Promise.resolve<GroupPermissions>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupPermissions>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Группа разрешений.
     */
    permissionsGroupsUpdate(data: GroupPermissions, company_id: string, id: number, cancelToken?: CancelToken): Promise<GroupPermissions> {
        let url_ = this.baseUrl + "/permissions/{company_id}/groups/{id}/update/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPermissionsGroupsUpdate(_response);
        });
    }

    protected processPermissionsGroupsUpdate(response: AxiosResponse): Promise<GroupPermissions> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GroupPermissions.fromJS(resultData200, _mappings);
            return Promise.resolve<GroupPermissions>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GroupPermissions>(null as any);
    }

    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    priceAllCompaniesList(name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous28> {
        let url_ = this.baseUrl + "/price/all_companies/list/?";
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceAllCompaniesList(_response);
        });
    }

    protected processPriceAllCompaniesList(response: AxiosResponse): Promise<Anonymous28> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous28.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous28>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous28>(null as any);
    }

    priceActiveEvacuation(company_id: string, cancelToken?: CancelToken): Promise<GetEvacuationPrice> {
        let url_ = this.baseUrl + "/price/{company_id}/active_evacuation/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceActiveEvacuation(_response);
        });
    }

    protected processPriceActiveEvacuation(response: AxiosResponse): Promise<GetEvacuationPrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetEvacuationPrice.fromJS(resultData200, _mappings);
            return Promise.resolve<GetEvacuationPrice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetEvacuationPrice>(null as any);
    }

    /**
     * @param name (optional) name
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    priceActiveList(company_id: string, name?: string | null | undefined, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous29> {
        let url_ = this.baseUrl + "/price/{company_id}/active_list/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (name !== undefined && name !== null)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceActiveList(_response);
        });
    }

    protected processPriceActiveList(response: AxiosResponse): Promise<Anonymous29> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous29.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous29>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous29>(null as any);
    }

    priceActiveTire(company_id: string, cancelToken?: CancelToken): Promise<GetTirePrice> {
        let url_ = this.baseUrl + "/price/{company_id}/active_tire/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceActiveTire(_response);
        });
    }

    protected processPriceActiveTire(response: AxiosResponse): Promise<GetTirePrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetTirePrice.fromJS(resultData200, _mappings);
            return Promise.resolve<GetTirePrice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTirePrice>(null as any);
    }

    priceActiveWash(company_id: string, cancelToken?: CancelToken): Promise<GetWashPrice> {
        let url_ = this.baseUrl + "/price/{company_id}/active_wash/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceActiveWash(_response);
        });
    }

    protected processPriceActiveWash(response: AxiosResponse): Promise<GetWashPrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetWashPrice.fromJS(resultData200, _mappings);
            return Promise.resolve<GetWashPrice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetWashPrice>(null as any);
    }

    priceCreate(company_id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/price/{company_id}/create/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceCreate(_response);
        });
    }

    protected processPriceCreate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ordering (optional) Which field to use when ordering the results.
     * @param page (optional) A page number within the paginated result set.
     * @param page_size (optional) Number of results to return per page.
     */
    priceHistory(company_id: string, ordering?: string | null | undefined, page?: number | null | undefined, page_size?: number | null | undefined, cancelToken?: CancelToken): Promise<Anonymous30> {
        let url_ = this.baseUrl + "/price/{company_id}/history/?";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (ordering !== undefined && ordering !== null)
            url_ += "ordering=" + encodeURIComponent("" + ordering) + "&";
        if (page !== undefined && page !== null)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (page_size !== undefined && page_size !== null)
            url_ += "page_size=" + encodeURIComponent("" + page_size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceHistory(_response);
        });
    }

    protected processPriceHistory(response: AxiosResponse): Promise<Anonymous30> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Anonymous30.fromJS(resultData200, _mappings);
            return Promise.resolve<Anonymous30>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Anonymous30>(null as any);
    }

    priceDoubling(company_id: string, id: string, cancelToken?: CancelToken): Promise<void> {
        let url_ = this.baseUrl + "/price/{company_id}/{id}/doubling/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceDoubling(_response);
        });
    }

    protected processPriceDoubling(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 201) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceEvacuation(company_id: string, id: number, cancelToken?: CancelToken): Promise<GetEvacuationPrice> {
        let url_ = this.baseUrl + "/price/{company_id}/{id}/evacuation/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceEvacuation(_response);
        });
    }

    protected processPriceEvacuation(response: AxiosResponse): Promise<GetEvacuationPrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetEvacuationPrice.fromJS(resultData200, _mappings);
            return Promise.resolve<GetEvacuationPrice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetEvacuationPrice>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceNewEvacuation(data: CreateNewPrice, company_id: string, id: number, cancelToken?: CancelToken): Promise<CreateNewPrice> {
        let url_ = this.baseUrl + "/price/{company_id}/{id}/new_evacuation/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceNewEvacuation(_response);
        });
    }

    protected processPriceNewEvacuation(response: AxiosResponse): Promise<CreateNewPrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CreateNewPrice.fromJS(resultData201, _mappings);
            return Promise.resolve<CreateNewPrice>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateNewPrice>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceNewTire(data: CreateNewPrice, company_id: string, id: number, cancelToken?: CancelToken): Promise<CreateNewPrice> {
        let url_ = this.baseUrl + "/price/{company_id}/{id}/new_tire/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceNewTire(_response);
        });
    }

    protected processPriceNewTire(response: AxiosResponse): Promise<CreateNewPrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CreateNewPrice.fromJS(resultData201, _mappings);
            return Promise.resolve<CreateNewPrice>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateNewPrice>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceNewWash(data: CreateNewPrice, company_id: string, id: number, cancelToken?: CancelToken): Promise<CreateNewPrice> {
        let url_ = this.baseUrl + "/price/{company_id}/{id}/new_wash/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceNewWash(_response);
        });
    }

    protected processPriceNewWash(response: AxiosResponse): Promise<CreateNewPrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CreateNewPrice.fromJS(resultData201, _mappings);
            return Promise.resolve<CreateNewPrice>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CreateNewPrice>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceTire(company_id: string, id: number, cancelToken?: CancelToken): Promise<GetTirePrice> {
        let url_ = this.baseUrl + "/price/{company_id}/{id}/tire/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceTire(_response);
        });
    }

    protected processPriceTire(response: AxiosResponse): Promise<GetTirePrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetTirePrice.fromJS(resultData200, _mappings);
            return Promise.resolve<GetTirePrice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetTirePrice>(null as any);
    }

    /**
     * @param id A unique integer value identifying this Прайс.
     */
    priceWash(company_id: string, id: number, cancelToken?: CancelToken): Promise<GetWashPrice> {
        let url_ = this.baseUrl + "/price/{company_id}/{id}/wash/";
        if (company_id === undefined || company_id === null)
            throw new Error("The parameter 'company_id' must be defined.");
        url_ = url_.replace("{company_id}", encodeURIComponent("" + company_id));
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPriceWash(_response);
        });
    }

    protected processPriceWash(response: AxiosResponse): Promise<GetWashPrice> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetWashPrice.fromJS(resultData200, _mappings);
            return Promise.resolve<GetWashPrice>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetWashPrice>(null as any);
    }

    token(data: CustomTokenObtainPair, cancelToken?: CancelToken): Promise<CustomTokenObtainPair> {
        let url_ = this.baseUrl + "/token/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processToken(_response);
        });
    }

    protected processToken(response: AxiosResponse): Promise<CustomTokenObtainPair> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = CustomTokenObtainPair.fromJS(resultData201, _mappings);
            return Promise.resolve<CustomTokenObtainPair>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CustomTokenObtainPair>(null as any);
    }

    tokenRefresh(data: TokenRefresh, cancelToken?: CancelToken): Promise<TokenRefresh> {
        let url_ = this.baseUrl + "/token/refresh/";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processTokenRefresh(_response);
        });
    }

    protected processTokenRefresh(response: AxiosResponse): Promise<TokenRefresh> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (const k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        let _mappings: { source: any, target: any }[] = [];
        if (status === 201) {
            const _responseText = response.data;
            let result201: any = null;
            let resultData201  = _responseText;
            result201 = TokenRefresh.fromJS(resultData201, _mappings);
            return Promise.resolve<TokenRefresh>(result201);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TokenRefresh>(null as any);
    }
}

export class _City implements I_City {
    readonly id?: number | undefined;
    name!: string;

    constructor(data?: I_City) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): _City | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_City>(data, _mappings, _City);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): _City {
        const json = this.toJSON();
        let result = new _City();
        result.init(json);
        return result;
    }
}

export interface I_City {
    id?: number | undefined;
    name: string;
}

export class _Parent implements I_Parent {
    readonly id?: number | undefined;
    name!: string;
    city!: number;
    is_active?: boolean | undefined;
    readonly parent_id?: string | undefined;

    constructor(data?: I_Parent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"];
            this.is_active = _data["is_active"];
            (<any>this).parent_id = _data["parent_id"];
        }
    }

    static fromJS(data: any, _mappings?: any): _Parent | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_Parent>(data, _mappings, _Parent);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city;
        data["is_active"] = this.is_active;
        data["parent_id"] = this.parent_id;
        return data;
    }

    clone(): _Parent {
        const json = this.toJSON();
        let result = new _Parent();
        result.init(json);
        return result;
    }
}

export interface I_Parent {
    id?: number | undefined;
    name: string;
    city: number;
    is_active?: boolean | undefined;
    parent_id?: string | undefined;
}

export class Company implements ICompany {
    readonly id?: number | undefined;
    name!: string;
    city!: _City;
    company_type?: Company_type | undefined;
    is_active?: boolean | undefined;
    readonly profile_id?: string | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    parent!: _Parent;

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.city = data.city && !(<any>data.city).toJSON ? new _City(data.city) : <_City>this.city;
            this.parent = data.parent && !(<any>data.parent).toJSON ? new _Parent(data.parent) : <_Parent>this.parent;
        }
        if (!data) {
            this.city = new _City();
            this.parent = new _Parent();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"] ? _City.fromJS(_data["city"], _mappings) : new _City();
            this.company_type = _data["company_type"];
            this.is_active = _data["is_active"];
            (<any>this).profile_id = _data["profile_id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.parent = _data["parent"] ? _Parent.fromJS(_data["parent"], _mappings) : new _Parent();
        }
    }

    static fromJS(data: any, _mappings?: any): Company | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Company>(data, _mappings, Company);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["company_type"] = this.company_type;
        data["is_active"] = this.is_active;
        data["profile_id"] = this.profile_id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data;
    }

    clone(): Company {
        const json = this.toJSON();
        let result = new Company();
        result.init(json);
        return result;
    }
}

export interface ICompany {
    id?: number | undefined;
    name: string;
    city: I_City;
    company_type?: Company_type | undefined;
    is_active?: boolean | undefined;
    profile_id?: string | undefined;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    parent: I_Parent;
}

export class _Permissions implements I_Permissions {
    readonly id?: number | undefined;
    name?: _PermissionsName | undefined;
    create?: boolean | undefined;
    read?: boolean | undefined;
    update?: boolean | undefined;
    delete?: boolean | undefined;

    constructor(data?: I_Permissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.create = _data["create"];
            this.read = _data["read"];
            this.update = _data["update"];
            this.delete = _data["delete"];
        }
    }

    static fromJS(data: any, _mappings?: any): _Permissions | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_Permissions>(data, _mappings, _Permissions);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["create"] = this.create;
        data["read"] = this.read;
        data["update"] = this.update;
        data["delete"] = this.delete;
        return data;
    }

    clone(): _Permissions {
        const json = this.toJSON();
        let result = new _Permissions();
        result.init(json);
        return result;
    }
}

export interface I_Permissions {
    id?: number | undefined;
    name?: _PermissionsName | undefined;
    create?: boolean | undefined;
    read?: boolean | undefined;
    update?: boolean | undefined;
    delete?: boolean | undefined;
}

export class GroupPermissions implements IGroupPermissions {
    readonly id?: number | undefined;
    name!: string;
    permissions!: _Permissions[];
    readonly created?: dayjs.Dayjs | undefined;

    constructor(data?: IGroupPermissions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.permissions) {
                this.permissions = [];
                for (let i = 0; i < data.permissions.length; i++) {
                    let item = data.permissions[i];
                    this.permissions[i] = item && !(<any>item).toJSON ? new _Permissions(item) : <_Permissions>item;
                }
            }
        }
        if (!data) {
            this.permissions = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(_Permissions.fromJS(item, _mappings));
            }
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): GroupPermissions | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GroupPermissions>(data, _mappings, GroupPermissions);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }

    clone(): GroupPermissions {
        const json = this.toJSON();
        let result = new GroupPermissions();
        result.init(json);
        return result;
    }
}

export interface IGroupPermissions {
    id?: number | undefined;
    name: string;
    permissions: I_Permissions[];
    created?: dayjs.Dayjs | undefined;
}

export class User implements IUser {
    readonly id?: number | undefined;
    phone!: string | undefined;
    email!: string;
    first_name!: string;
    last_name!: string;
    group!: number;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    date_joined?: dayjs.Dayjs | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.group = _data["group"];
            this.is_active = _data["is_active"];
            this.date_joined = _data["date_joined"] ? dayjs(_data["date_joined"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): User | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<User>(data, _mappings, User);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["group"] = this.group;
        data["is_active"] = this.is_active;
        data["date_joined"] = this.date_joined ? this.date_joined.toISOString() : <any>undefined;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id?: number | undefined;
    phone: string | undefined;
    email: string;
    first_name: string;
    last_name: string;
    group: number;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    date_joined?: dayjs.Dayjs | undefined;
}

export class AccountBinding implements IAccountBinding {
    company?: Company | undefined;
    group?: GroupPermissions | undefined;
    employee?: User | undefined;

    constructor(data?: IAccountBinding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.company = data.company && !(<any>data.company).toJSON ? new Company(data.company) : <Company>this.company;
            this.group = data.group && !(<any>data.group).toJSON ? new GroupPermissions(data.group) : <GroupPermissions>this.group;
            this.employee = data.employee && !(<any>data.employee).toJSON ? new User(data.employee) : <User>this.employee;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.company = _data["company"] ? Company.fromJS(_data["company"], _mappings) : <any>undefined;
            this.group = _data["group"] ? GroupPermissions.fromJS(_data["group"], _mappings) : <any>undefined;
            this.employee = _data["employee"] ? User.fromJS(_data["employee"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): AccountBinding | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AccountBinding>(data, _mappings, AccountBinding);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        return data;
    }

    clone(): AccountBinding {
        const json = this.toJSON();
        let result = new AccountBinding();
        result.init(json);
        return result;
    }
}

export interface IAccountBinding {
    company?: ICompany | undefined;
    group?: IGroupPermissions | undefined;
    employee?: IUser | undefined;
}

export class ChangeEmailByOwner implements IChangeEmailByOwner {
    email!: string;

    constructor(data?: IChangeEmailByOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangeEmailByOwner | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangeEmailByOwner>(data, _mappings, ChangeEmailByOwner);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }

    clone(): ChangeEmailByOwner {
        const json = this.toJSON();
        let result = new ChangeEmailByOwner();
        result.init(json);
        return result;
    }
}

export interface IChangeEmailByOwner {
    email: string;
}

export class ChangePassword implements IChangePassword {
    old_password!: string;
    password!: string;
    password2!: string;

    constructor(data?: IChangePassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.old_password = _data["old_password"];
            this.password = _data["password"];
            this.password2 = _data["password2"];
        }
    }

    static fromJS(data: any, _mappings?: any): ChangePassword | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ChangePassword>(data, _mappings, ChangePassword);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["old_password"] = this.old_password;
        data["password"] = this.password;
        data["password2"] = this.password2;
        return data;
    }

    clone(): ChangePassword {
        const json = this.toJSON();
        let result = new ChangePassword();
        result.init(json);
        return result;
    }
}

export interface IChangePassword {
    old_password: string;
    password: string;
    password2: string;
}

export class _UserCompanies implements I_UserCompanies {
    company?: Company | undefined;
    group?: GroupPermissions | undefined;
    readonly id?: number | undefined;

    constructor(data?: I_UserCompanies) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.company = data.company && !(<any>data.company).toJSON ? new Company(data.company) : <Company>this.company;
            this.group = data.group && !(<any>data.group).toJSON ? new GroupPermissions(data.group) : <GroupPermissions>this.group;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.company = _data["company"] ? Company.fromJS(_data["company"], _mappings) : <any>undefined;
            this.group = _data["group"] ? GroupPermissions.fromJS(_data["group"], _mappings) : <any>undefined;
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any, _mappings?: any): _UserCompanies | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_UserCompanies>(data, _mappings, _UserCompanies);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): _UserCompanies {
        const json = this.toJSON();
        let result = new _UserCompanies();
        result.init(json);
        return result;
    }
}

export interface I_UserCompanies {
    company?: ICompany | undefined;
    group?: IGroupPermissions | undefined;
    id?: number | undefined;
}

export class OwnProfile implements IOwnProfile {
    phone?: string | undefined;
    email!: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    /** Указывает, что пользователь имеет все права без явного их назначения. */
    is_superuser?: boolean | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    readonly account_bindings?: _UserCompanies[] | undefined;
    readonly id?: number | undefined;
    date_joined?: dayjs.Dayjs | undefined;

    constructor(data?: IOwnProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.account_bindings) {
                this.account_bindings = [];
                for (let i = 0; i < data.account_bindings.length; i++) {
                    let item = data.account_bindings[i];
                    this.account_bindings[i] = item && !(<any>item).toJSON ? new _UserCompanies(item) : <_UserCompanies>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.is_superuser = _data["is_superuser"];
            this.is_active = _data["is_active"];
            if (Array.isArray(_data["account_bindings"])) {
                (<any>this).account_bindings = [] as any;
                for (let item of _data["account_bindings"])
                    (<any>this).account_bindings!.push(_UserCompanies.fromJS(item, _mappings));
            }
            (<any>this).id = _data["id"];
            this.date_joined = _data["date_joined"] ? dayjs(_data["date_joined"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): OwnProfile | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<OwnProfile>(data, _mappings, OwnProfile);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["is_superuser"] = this.is_superuser;
        data["is_active"] = this.is_active;
        if (Array.isArray(this.account_bindings)) {
            data["account_bindings"] = [];
            for (let item of this.account_bindings)
                data["account_bindings"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["date_joined"] = this.date_joined ? this.date_joined.toISOString() : <any>undefined;
        return data;
    }

    clone(): OwnProfile {
        const json = this.toJSON();
        let result = new OwnProfile();
        result.init(json);
        return result;
    }
}

export interface IOwnProfile {
    phone?: string | undefined;
    email: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    /** Указывает, что пользователь имеет все права без явного их назначения. */
    is_superuser?: boolean | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    account_bindings?: I_UserCompanies[] | undefined;
    id?: number | undefined;
    date_joined?: dayjs.Dayjs | undefined;
}

export class Register implements IRegister {
    phone!: string | undefined;
    password!: string;
    password2!: string;
    email!: string;
    first_name!: string;
    last_name!: string;

    constructor(data?: IRegister) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.password = _data["password"];
            this.password2 = _data["password2"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
        }
    }

    static fromJS(data: any, _mappings?: any): Register | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Register>(data, _mappings, Register);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["password"] = this.password;
        data["password2"] = this.password2;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        return data;
    }

    clone(): Register {
        const json = this.toJSON();
        let result = new Register();
        result.init(json);
        return result;
    }
}

export interface IRegister {
    phone: string | undefined;
    password: string;
    password2: string;
    email: string;
    first_name: string;
    last_name: string;
}

export class UpdateUser implements IUpdateUser {
    first_name!: string;
    last_name!: string;
    email!: string;
    phone?: string | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    group!: number;

    constructor(data?: IUpdateUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.is_active = _data["is_active"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any, _mappings?: any): UpdateUser | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UpdateUser>(data, _mappings, UpdateUser);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["is_active"] = this.is_active;
        data["group"] = this.group;
        return data;
    }

    clone(): UpdateUser {
        const json = this.toJSON();
        let result = new UpdateUser();
        result.init(json);
        return result;
    }
}

export interface IUpdateUser {
    first_name: string;
    last_name: string;
    email: string;
    phone?: string | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    group: number;
}

export class _Profile implements I_Profile {
    phone?: string | undefined;
    email!: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    readonly id?: number | undefined;

    constructor(data?: I_Profile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.is_active = _data["is_active"];
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any, _mappings?: any): _Profile | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_Profile>(data, _mappings, _Profile);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["is_active"] = this.is_active;
        data["id"] = this.id;
        return data;
    }

    clone(): _Profile {
        const json = this.toJSON();
        let result = new _Profile();
        result.init(json);
        return result;
    }
}

export interface I_Profile {
    phone?: string | undefined;
    email: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    id?: number | undefined;
}

export class CompanyAccountBinding implements ICompanyAccountBinding {
    group?: GroupPermissions | undefined;
    employee?: _Profile | undefined;
    company?: Company | undefined;

    constructor(data?: ICompanyAccountBinding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.group = data.group && !(<any>data.group).toJSON ? new GroupPermissions(data.group) : <GroupPermissions>this.group;
            this.employee = data.employee && !(<any>data.employee).toJSON ? new _Profile(data.employee) : <_Profile>this.employee;
            this.company = data.company && !(<any>data.company).toJSON ? new Company(data.company) : <Company>this.company;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.group = _data["group"] ? GroupPermissions.fromJS(_data["group"], _mappings) : <any>undefined;
            this.employee = _data["employee"] ? _Profile.fromJS(_data["employee"], _mappings) : <any>undefined;
            this.company = _data["company"] ? Company.fromJS(_data["company"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): CompanyAccountBinding | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CompanyAccountBinding>(data, _mappings, CompanyAccountBinding);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data;
    }

    clone(): CompanyAccountBinding {
        const json = this.toJSON();
        let result = new CompanyAccountBinding();
        result.init(json);
        return result;
    }
}

export interface ICompanyAccountBinding {
    group?: IGroupPermissions | undefined;
    employee?: I_Profile | undefined;
    company?: ICompany | undefined;
}

export class UserCreate implements IUserCreate {
    readonly id?: number | undefined;
    phone!: string | undefined;
    email!: string;
    first_name!: string;
    last_name!: string;
    group?: number | undefined;
    company?: number | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;

    constructor(data?: IUserCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.group = _data["group"];
            this.company = _data["company"];
            this.is_active = _data["is_active"];
        }
    }

    static fromJS(data: any, _mappings?: any): UserCreate | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserCreate>(data, _mappings, UserCreate);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["group"] = this.group;
        data["company"] = this.company;
        data["is_active"] = this.is_active;
        return data;
    }

    clone(): UserCreate {
        const json = this.toJSON();
        let result = new UserCreate();
        result.init(json);
        return result;
    }
}

export interface IUserCreate {
    id?: number | undefined;
    phone: string | undefined;
    email: string;
    first_name: string;
    last_name: string;
    group?: number | undefined;
    company?: number | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
}

export class _AccountBinding implements I_AccountBinding {
    company?: Company | undefined;
    group?: GroupPermissions | undefined;
    readonly id?: number | undefined;

    constructor(data?: I_AccountBinding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.company = data.company && !(<any>data.company).toJSON ? new Company(data.company) : <Company>this.company;
            this.group = data.group && !(<any>data.group).toJSON ? new GroupPermissions(data.group) : <GroupPermissions>this.group;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.company = _data["company"] ? Company.fromJS(_data["company"], _mappings) : <any>undefined;
            this.group = _data["group"] ? GroupPermissions.fromJS(_data["group"], _mappings) : <any>undefined;
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any, _mappings?: any): _AccountBinding | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_AccountBinding>(data, _mappings, _AccountBinding);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data;
    }

    clone(): _AccountBinding {
        const json = this.toJSON();
        let result = new _AccountBinding();
        result.init(json);
        return result;
    }
}

export interface I_AccountBinding {
    company?: ICompany | undefined;
    group?: IGroupPermissions | undefined;
    id?: number | undefined;
}

export class UserRetrieve implements IUserRetrieve {
    readonly id?: number | undefined;
    phone?: string | undefined;
    email!: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    readonly account_bindings?: _AccountBinding[] | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;

    constructor(data?: IUserRetrieve) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.account_bindings) {
                this.account_bindings = [];
                for (let i = 0; i < data.account_bindings.length; i++) {
                    let item = data.account_bindings[i];
                    this.account_bindings[i] = item && !(<any>item).toJSON ? new _AccountBinding(item) : <_AccountBinding>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            if (Array.isArray(_data["account_bindings"])) {
                (<any>this).account_bindings = [] as any;
                for (let item of _data["account_bindings"])
                    (<any>this).account_bindings!.push(_AccountBinding.fromJS(item, _mappings));
            }
            this.is_active = _data["is_active"];
        }
    }

    static fromJS(data: any, _mappings?: any): UserRetrieve | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserRetrieve>(data, _mappings, UserRetrieve);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        if (Array.isArray(this.account_bindings)) {
            data["account_bindings"] = [];
            for (let item of this.account_bindings)
                data["account_bindings"].push(item.toJSON());
        }
        data["is_active"] = this.is_active;
        return data;
    }

    clone(): UserRetrieve {
        const json = this.toJSON();
        let result = new UserRetrieve();
        result.init(json);
        return result;
    }
}

export interface IUserRetrieve {
    id?: number | undefined;
    phone?: string | undefined;
    email: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    account_bindings?: I_AccountBinding[] | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
}

export class Transaction implements ITransaction {
    readonly id?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    amount!: number;
    purpose?: string | undefined;
    is_active?: boolean | undefined;
    balance!: number;
    ts_maker!: number;
    bid?: number | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.purpose = _data["purpose"];
            this.is_active = _data["is_active"];
            this.balance = _data["balance"];
            this.ts_maker = _data["ts_maker"];
            this.bid = _data["bid"];
        }
    }

    static fromJS(data: any, _mappings?: any): Transaction | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Transaction>(data, _mappings, Transaction);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["purpose"] = this.purpose;
        data["is_active"] = this.is_active;
        data["balance"] = this.balance;
        data["ts_maker"] = this.ts_maker;
        data["bid"] = this.bid;
        return data;
    }

    clone(): Transaction {
        const json = this.toJSON();
        let result = new Transaction();
        result.init(json);
        return result;
    }
}

export interface ITransaction {
    id?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    amount: number;
    purpose?: string | undefined;
    is_active?: boolean | undefined;
    balance: number;
    ts_maker: number;
    bid?: number | undefined;
}

export class BidPhoto implements IBidPhoto {
    readonly id?: number | undefined;
    is_before?: boolean | undefined;
    readonly foto?: string | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    bid?: number | undefined;

    constructor(data?: IBidPhoto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.is_before = _data["is_before"];
            (<any>this).foto = _data["foto"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            this.bid = _data["bid"];
        }
    }

    static fromJS(data: any, _mappings?: any): BidPhoto | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidPhoto>(data, _mappings, BidPhoto);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["is_before"] = this.is_before;
        data["foto"] = this.foto;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["bid"] = this.bid;
        return data;
    }

    clone(): BidPhoto {
        const json = this.toJSON();
        let result = new BidPhoto();
        result.init(json);
        return result;
    }
}

export interface IBidPhoto {
    id?: number | undefined;
    is_before?: boolean | undefined;
    foto?: string | undefined;
    created?: dayjs.Dayjs | undefined;
    bid?: number | undefined;
}

export class _BidEmployee implements I_BidEmployee {
    phone?: string | undefined;
    email!: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    readonly id?: number | undefined;

    constructor(data?: I_BidEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any, _mappings?: any): _BidEmployee | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_BidEmployee>(data, _mappings, _BidEmployee);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["id"] = this.id;
        return data;
    }

    clone(): _BidEmployee {
        const json = this.toJSON();
        let result = new _BidEmployee();
        result.init(json);
        return result;
    }
}

export interface I_BidEmployee {
    phone?: string | undefined;
    email: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    id?: number | undefined;
}

export class CarBrand implements ICarBrand {
    readonly id?: number | undefined;
    name!: string;

    constructor(data?: ICarBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): CarBrand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CarBrand>(data, _mappings, CarBrand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): CarBrand {
        const json = this.toJSON();
        let result = new CarBrand();
        result.init(json);
        return result;
    }
}

export interface ICarBrand {
    id?: number | undefined;
    name: string;
}

export class CarModel implements ICarModel {
    readonly id?: number | undefined;
    name!: string;
    car_type?: CarModelCar_type | undefined;
    brand!: number;

    constructor(data?: ICarModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.car_type = _data["car_type"];
            this.brand = _data["brand"];
        }
    }

    static fromJS(data: any, _mappings?: any): CarModel | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CarModel>(data, _mappings, CarModel);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["car_type"] = this.car_type;
        data["brand"] = this.brand;
        return data;
    }

    clone(): CarModel {
        const json = this.toJSON();
        let result = new CarModel();
        result.init(json);
        return result;
    }
}

export interface ICarModel {
    id?: number | undefined;
    name: string;
    car_type?: CarModelCar_type | undefined;
    brand: number;
}

export class _Car implements I_Car {
    readonly id?: number | undefined;
    brand?: CarBrand | undefined;
    model?: CarModel | undefined;
    number!: string;

    constructor(data?: I_Car) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.brand = data.brand && !(<any>data.brand).toJSON ? new CarBrand(data.brand) : <CarBrand>this.brand;
            this.model = data.model && !(<any>data.model).toJSON ? new CarModel(data.model) : <CarModel>this.model;
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.brand = _data["brand"] ? CarBrand.fromJS(_data["brand"], _mappings) : <any>undefined;
            this.model = _data["model"] ? CarModel.fromJS(_data["model"], _mappings) : <any>undefined;
            this.number = _data["number"];
        }
    }

    static fromJS(data: any, _mappings?: any): _Car | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_Car>(data, _mappings, _Car);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["number"] = this.number;
        return data;
    }

    clone(): _Car {
        const json = this.toJSON();
        let result = new _Car();
        result.init(json);
        return result;
    }
}

export interface I_Car {
    id?: number | undefined;
    brand?: ICarBrand | undefined;
    model?: ICarModel | undefined;
    number: string;
}

export class _ServiceType implements I_ServiceType {
    readonly id?: number | undefined;
    name!: string;

    constructor(data?: I_ServiceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): _ServiceType | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_ServiceType>(data, _mappings, _ServiceType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): _ServiceType {
        const json = this.toJSON();
        let result = new _ServiceType();
        result.init(json);
        return result;
    }
}

export interface I_ServiceType {
    id?: number | undefined;
    name: string;
}

export class _ServiceSubtype implements I_ServiceSubtype {
    readonly id?: number | undefined;
    name!: string;

    constructor(data?: I_ServiceSubtype) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): _ServiceSubtype | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_ServiceSubtype>(data, _mappings, _ServiceSubtype);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): _ServiceSubtype {
        const json = this.toJSON();
        let result = new _ServiceSubtype();
        result.init(json);
        return result;
    }
}

export interface I_ServiceSubtype {
    id?: number | undefined;
    name: string;
}

export class _ServiceOption implements I_ServiceOption {
    readonly id?: number | undefined;
    name!: string;

    constructor(data?: I_ServiceOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any, _mappings?: any): _ServiceOption | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_ServiceOption>(data, _mappings, _ServiceOption);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): _ServiceOption {
        const json = this.toJSON();
        let result = new _ServiceOption();
        result.init(json);
        return result;
    }
}

export interface I_ServiceOption {
    id?: number | undefined;
    name: string;
}

export class BidRetrieve implements IBidRetrieve {
    readonly id?: number | undefined;
    status?: BidRetrieveStatus | undefined;
    author!: _BidEmployee;
    performer!: Company;
    executor!: _BidEmployee;
    company!: Company;
    conductor!: _BidEmployee;
    car!: _Car;
    service_type!: _ServiceType;
    service_subtype!: _ServiceSubtype;
    service_option!: _ServiceOption[];
    phone?: string | undefined;
    /** эвакуатор или манипулятор */
    truck_type?: BidRetrieveTruck_type | undefined;
    customer_comment?: string | undefined;
    /** Заполнять вот так: POINT (37.50416183902333 55.82400586279539) */
    geog_from?: string | undefined;
    address_from?: string | undefined;
    /** Заполнять вот так: POINT (37.50416183902333 55.82400586279539) */
    geog_to?: string | undefined;
    address_to?: string | undefined;
    schedule?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    create_amount?: number | undefined;
    distance?: number | undefined;
    wheel_lock?: number | undefined;
    keys?: BidRetrieveKeys | undefined;
    is_parking?: boolean | undefined;
    /** Структура типа {<позиция прайса>:<стоимость>} */
    price_positions?: any | undefined;

    constructor(data?: IBidRetrieve) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.author = data.author && !(<any>data.author).toJSON ? new _BidEmployee(data.author) : <_BidEmployee>this.author;
            this.performer = data.performer && !(<any>data.performer).toJSON ? new Company(data.performer) : <Company>this.performer;
            this.executor = data.executor && !(<any>data.executor).toJSON ? new _BidEmployee(data.executor) : <_BidEmployee>this.executor;
            this.company = data.company && !(<any>data.company).toJSON ? new Company(data.company) : <Company>this.company;
            this.conductor = data.conductor && !(<any>data.conductor).toJSON ? new _BidEmployee(data.conductor) : <_BidEmployee>this.conductor;
            this.car = data.car && !(<any>data.car).toJSON ? new _Car(data.car) : <_Car>this.car;
            this.service_type = data.service_type && !(<any>data.service_type).toJSON ? new _ServiceType(data.service_type) : <_ServiceType>this.service_type;
            this.service_subtype = data.service_subtype && !(<any>data.service_subtype).toJSON ? new _ServiceSubtype(data.service_subtype) : <_ServiceSubtype>this.service_subtype;
            if (data.service_option) {
                this.service_option = [];
                for (let i = 0; i < data.service_option.length; i++) {
                    let item = data.service_option[i];
                    this.service_option[i] = item && !(<any>item).toJSON ? new _ServiceOption(item) : <_ServiceOption>item;
                }
            }
        }
        if (!data) {
            this.author = new _BidEmployee();
            this.performer = new Company();
            this.executor = new _BidEmployee();
            this.company = new Company();
            this.conductor = new _BidEmployee();
            this.car = new _Car();
            this.service_type = new _ServiceType();
            this.service_subtype = new _ServiceSubtype();
            this.service_option = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.status = _data["status"];
            this.author = _data["author"] ? _BidEmployee.fromJS(_data["author"], _mappings) : new _BidEmployee();
            this.performer = _data["performer"] ? Company.fromJS(_data["performer"], _mappings) : new Company();
            this.executor = _data["executor"] ? _BidEmployee.fromJS(_data["executor"], _mappings) : new _BidEmployee();
            this.company = _data["company"] ? Company.fromJS(_data["company"], _mappings) : new Company();
            this.conductor = _data["conductor"] ? _BidEmployee.fromJS(_data["conductor"], _mappings) : new _BidEmployee();
            this.car = _data["car"] ? _Car.fromJS(_data["car"], _mappings) : new _Car();
            this.service_type = _data["service_type"] ? _ServiceType.fromJS(_data["service_type"], _mappings) : new _ServiceType();
            this.service_subtype = _data["service_subtype"] ? _ServiceSubtype.fromJS(_data["service_subtype"], _mappings) : new _ServiceSubtype();
            if (Array.isArray(_data["service_option"])) {
                this.service_option = [] as any;
                for (let item of _data["service_option"])
                    this.service_option!.push(_ServiceOption.fromJS(item, _mappings));
            }
            this.phone = _data["phone"];
            this.truck_type = _data["truck_type"];
            this.customer_comment = _data["customer_comment"];
            this.geog_from = _data["geog_from"];
            this.address_from = _data["address_from"];
            this.geog_to = _data["geog_to"];
            this.address_to = _data["address_to"];
            this.schedule = _data["schedule"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.create_amount = _data["create_amount"];
            this.distance = _data["distance"];
            this.wheel_lock = _data["wheel_lock"];
            this.keys = _data["keys"];
            this.is_parking = _data["is_parking"];
            this.price_positions = _data["price_positions"];
        }
    }

    static fromJS(data: any, _mappings?: any): BidRetrieve | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidRetrieve>(data, _mappings, BidRetrieve);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["performer"] = this.performer ? this.performer.toJSON() : <any>undefined;
        data["executor"] = this.executor ? this.executor.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["conductor"] = this.conductor ? this.conductor.toJSON() : <any>undefined;
        data["car"] = this.car ? this.car.toJSON() : <any>undefined;
        data["service_type"] = this.service_type ? this.service_type.toJSON() : <any>undefined;
        data["service_subtype"] = this.service_subtype ? this.service_subtype.toJSON() : <any>undefined;
        if (Array.isArray(this.service_option)) {
            data["service_option"] = [];
            for (let item of this.service_option)
                data["service_option"].push(item.toJSON());
        }
        data["phone"] = this.phone;
        data["truck_type"] = this.truck_type;
        data["customer_comment"] = this.customer_comment;
        data["geog_from"] = this.geog_from;
        data["address_from"] = this.address_from;
        data["geog_to"] = this.geog_to;
        data["address_to"] = this.address_to;
        data["schedule"] = this.schedule;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["create_amount"] = this.create_amount;
        data["distance"] = this.distance;
        data["wheel_lock"] = this.wheel_lock;
        data["keys"] = this.keys;
        data["is_parking"] = this.is_parking;
        data["price_positions"] = this.price_positions;
        return data;
    }

    clone(): BidRetrieve {
        const json = this.toJSON();
        let result = new BidRetrieve();
        result.init(json);
        return result;
    }
}

export interface IBidRetrieve {
    id?: number | undefined;
    status?: BidRetrieveStatus | undefined;
    author: I_BidEmployee;
    performer: ICompany;
    executor: I_BidEmployee;
    company: ICompany;
    conductor: I_BidEmployee;
    car: I_Car;
    service_type: I_ServiceType;
    service_subtype: I_ServiceSubtype;
    service_option: I_ServiceOption[];
    phone?: string | undefined;
    /** эвакуатор или манипулятор */
    truck_type?: BidRetrieveTruck_type | undefined;
    customer_comment?: string | undefined;
    /** Заполнять вот так: POINT (37.50416183902333 55.82400586279539) */
    geog_from?: string | undefined;
    address_from?: string | undefined;
    /** Заполнять вот так: POINT (37.50416183902333 55.82400586279539) */
    geog_to?: string | undefined;
    address_to?: string | undefined;
    schedule?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    create_amount?: number | undefined;
    distance?: number | undefined;
    wheel_lock?: number | undefined;
    keys?: BidRetrieveKeys | undefined;
    is_parking?: boolean | undefined;
    /** Структура типа {<позиция прайса>:<стоимость>} */
    price_positions?: any | undefined;
}

export class BidPerformer implements IBidPerformer {
    car_id!: number;
    subtype_id!: number;
    options_idx?: number[] | undefined;

    constructor(data?: IBidPerformer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.car_id = _data["car_id"];
            this.subtype_id = _data["subtype_id"];
            if (Array.isArray(_data["options_idx"])) {
                this.options_idx = [] as any;
                for (let item of _data["options_idx"])
                    this.options_idx!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): BidPerformer | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidPerformer>(data, _mappings, BidPerformer);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["car_id"] = this.car_id;
        data["subtype_id"] = this.subtype_id;
        if (Array.isArray(this.options_idx)) {
            data["options_idx"] = [];
            for (let item of this.options_idx)
                data["options_idx"].push(item);
        }
        return data;
    }

    clone(): BidPerformer {
        const json = this.toJSON();
        let result = new BidPerformer();
        result.init(json);
        return result;
    }
}

export interface IBidPerformer {
    car_id: number;
    subtype_id: number;
    options_idx?: number[] | undefined;
}

export class BidCreate implements IBidCreate {
    readonly id?: number | undefined;
    performer!: number;
    readonly executor?: number | undefined;
    company!: number;
    conductor!: number;
    car!: number;
    city!: number;
    is_parking?: boolean | undefined;
    keys?: BidCreateKeys | undefined;
    wheel_lock?: number | undefined;
    distance?: number | undefined;
    service_type!: number;
    service_subtype!: number;
    service_option?: number[] | undefined;
    phone?: string | undefined;
    /** эвакуатор или манипулятор */
    truck_type?: BidCreateTruck_type | undefined;
    customer_comment?: string | undefined;
    lat_from?: number | undefined;
    lon_from?: number | undefined;
    lat_to?: number | undefined;
    lon_to?: number | undefined;
    schedule?: number | undefined;
    address_from?: string | undefined;
    address_to?: string | undefined;
    readonly create_amount?: number | undefined;
    fotos?: number[] | undefined;
    /** Структура типа {<позиция прайса>:<стоимость>} */
    readonly price_positions?: any | undefined;

    constructor(data?: IBidCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.performer = _data["performer"];
            (<any>this).executor = _data["executor"];
            this.company = _data["company"];
            this.conductor = _data["conductor"];
            this.car = _data["car"];
            this.city = _data["city"];
            this.is_parking = _data["is_parking"];
            this.keys = _data["keys"];
            this.wheel_lock = _data["wheel_lock"];
            this.distance = _data["distance"];
            this.service_type = _data["service_type"];
            this.service_subtype = _data["service_subtype"];
            if (Array.isArray(_data["service_option"])) {
                this.service_option = [] as any;
                for (let item of _data["service_option"])
                    this.service_option!.push(item);
            }
            this.phone = _data["phone"];
            this.truck_type = _data["truck_type"];
            this.customer_comment = _data["customer_comment"];
            this.lat_from = _data["lat_from"];
            this.lon_from = _data["lon_from"];
            this.lat_to = _data["lat_to"];
            this.lon_to = _data["lon_to"];
            this.schedule = _data["schedule"];
            this.address_from = _data["address_from"];
            this.address_to = _data["address_to"];
            (<any>this).create_amount = _data["create_amount"];
            if (Array.isArray(_data["fotos"])) {
                this.fotos = [] as any;
                for (let item of _data["fotos"])
                    this.fotos!.push(item);
            }
            (<any>this).price_positions = _data["price_positions"];
        }
    }

    static fromJS(data: any, _mappings?: any): BidCreate | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidCreate>(data, _mappings, BidCreate);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["performer"] = this.performer;
        data["executor"] = this.executor;
        data["company"] = this.company;
        data["conductor"] = this.conductor;
        data["car"] = this.car;
        data["city"] = this.city;
        data["is_parking"] = this.is_parking;
        data["keys"] = this.keys;
        data["wheel_lock"] = this.wheel_lock;
        data["distance"] = this.distance;
        data["service_type"] = this.service_type;
        data["service_subtype"] = this.service_subtype;
        if (Array.isArray(this.service_option)) {
            data["service_option"] = [];
            for (let item of this.service_option)
                data["service_option"].push(item);
        }
        data["phone"] = this.phone;
        data["truck_type"] = this.truck_type;
        data["customer_comment"] = this.customer_comment;
        data["lat_from"] = this.lat_from;
        data["lon_from"] = this.lon_from;
        data["lat_to"] = this.lat_to;
        data["lon_to"] = this.lon_to;
        data["schedule"] = this.schedule;
        data["address_from"] = this.address_from;
        data["address_to"] = this.address_to;
        data["create_amount"] = this.create_amount;
        if (Array.isArray(this.fotos)) {
            data["fotos"] = [];
            for (let item of this.fotos)
                data["fotos"].push(item);
        }
        data["price_positions"] = this.price_positions;
        return data;
    }

    clone(): BidCreate {
        const json = this.toJSON();
        let result = new BidCreate();
        result.init(json);
        return result;
    }
}

export interface IBidCreate {
    id?: number | undefined;
    performer: number;
    executor?: number | undefined;
    company: number;
    conductor: number;
    car: number;
    city: number;
    is_parking?: boolean | undefined;
    keys?: BidCreateKeys | undefined;
    wheel_lock?: number | undefined;
    distance?: number | undefined;
    service_type: number;
    service_subtype: number;
    service_option?: number[] | undefined;
    phone?: string | undefined;
    /** эвакуатор или манипулятор */
    truck_type?: BidCreateTruck_type | undefined;
    customer_comment?: string | undefined;
    lat_from?: number | undefined;
    lon_from?: number | undefined;
    lat_to?: number | undefined;
    lon_to?: number | undefined;
    schedule?: number | undefined;
    address_from?: string | undefined;
    address_to?: string | undefined;
    create_amount?: number | undefined;
    fotos?: number[] | undefined;
    /** Структура типа {<позиция прайса>:<стоимость>} */
    price_positions?: any | undefined;
}

export class BidCustomerComment implements IBidCustomerComment {
    customer_comment?: string | undefined;

    constructor(data?: IBidCustomerComment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.customer_comment = _data["customer_comment"];
        }
    }

    static fromJS(data: any, _mappings?: any): BidCustomerComment | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidCustomerComment>(data, _mappings, BidCustomerComment);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer_comment"] = this.customer_comment;
        return data;
    }

    clone(): BidCustomerComment {
        const json = this.toJSON();
        let result = new BidCustomerComment();
        result.init(json);
        return result;
    }
}

export interface IBidCustomerComment {
    customer_comment?: string | undefined;
}

export class BidExecutor implements IBidExecutor {
    executor?: number | undefined;

    constructor(data?: IBidExecutor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.executor = _data["executor"];
        }
    }

    static fromJS(data: any, _mappings?: any): BidExecutor | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidExecutor>(data, _mappings, BidExecutor);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["executor"] = this.executor;
        return data;
    }

    clone(): BidExecutor {
        const json = this.toJSON();
        let result = new BidExecutor();
        result.init(json);
        return result;
    }
}

export interface IBidExecutor {
    executor?: number | undefined;
}

export class BidHistory implements IBidHistory {
    readonly id?: number | undefined;
    user!: _BidEmployee;
    readonly old_status?: string | undefined;
    readonly new_status?: string | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    additional_information?: string | undefined;
    bid!: number;

    constructor(data?: IBidHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new _BidEmployee(data.user) : <_BidEmployee>this.user;
        }
        if (!data) {
            this.user = new _BidEmployee();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.user = _data["user"] ? _BidEmployee.fromJS(_data["user"], _mappings) : new _BidEmployee();
            (<any>this).old_status = _data["old_status"];
            (<any>this).new_status = _data["new_status"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.additional_information = _data["additional_information"];
            this.bid = _data["bid"];
        }
    }

    static fromJS(data: any, _mappings?: any): BidHistory | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidHistory>(data, _mappings, BidHistory);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["old_status"] = this.old_status;
        data["new_status"] = this.new_status;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["additional_information"] = this.additional_information;
        data["bid"] = this.bid;
        return data;
    }

    clone(): BidHistory {
        const json = this.toJSON();
        let result = new BidHistory();
        result.init(json);
        return result;
    }
}

export interface IBidHistory {
    id?: number | undefined;
    user: I_BidEmployee;
    old_status?: string | undefined;
    new_status?: string | undefined;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    additional_information?: string | undefined;
    bid: number;
}

export class BidService implements IBidService {
    service_subtype!: number;
    service_option?: number[] | undefined;

    constructor(data?: IBidService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.service_subtype = _data["service_subtype"];
            if (Array.isArray(_data["service_option"])) {
                this.service_option = [] as any;
                for (let item of _data["service_option"])
                    this.service_option!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): BidService | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidService>(data, _mappings, BidService);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["service_subtype"] = this.service_subtype;
        if (Array.isArray(this.service_option)) {
            data["service_option"] = [];
            for (let item of this.service_option)
                data["service_option"].push(item);
        }
        return data;
    }

    clone(): BidService {
        const json = this.toJSON();
        let result = new BidService();
        result.init(json);
        return result;
    }
}

export interface IBidService {
    service_subtype: number;
    service_option?: number[] | undefined;
}

export class BidStatus implements IBidStatus {
    status?: BidStatusStatus | undefined;
    fotos?: number[] | undefined;

    constructor(data?: IBidStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.status = _data["status"];
            if (Array.isArray(_data["fotos"])) {
                this.fotos = [] as any;
                for (let item of _data["fotos"])
                    this.fotos!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): BidStatus | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BidStatus>(data, _mappings, BidStatus);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        if (Array.isArray(this.fotos)) {
            data["fotos"] = [];
            for (let item of this.fotos)
                data["fotos"].push(item);
        }
        return data;
    }

    clone(): BidStatus {
        const json = this.toJSON();
        let result = new BidStatus();
        result.init(json);
        return result;
    }
}

export interface IBidStatus {
    status?: BidStatusStatus | undefined;
    fotos?: number[] | undefined;
}

export class CarCreateUpdate implements ICarCreateUpdate {
    readonly id?: number | undefined;
    number!: string;
    height?: number | undefined;
    radius?: CarCreateUpdateRadius | undefined;
    is_active!: boolean;
    brand!: number;
    model!: number;
    employees?: number[] | undefined;

    constructor(data?: ICarCreateUpdate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.number = _data["number"];
            this.height = _data["height"];
            this.radius = _data["radius"];
            this.is_active = _data["is_active"];
            this.brand = _data["brand"];
            this.model = _data["model"];
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(item);
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CarCreateUpdate | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CarCreateUpdate>(data, _mappings, CarCreateUpdate);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["number"] = this.number;
        data["height"] = this.height;
        data["radius"] = this.radius;
        data["is_active"] = this.is_active;
        data["brand"] = this.brand;
        data["model"] = this.model;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item);
        }
        return data;
    }

    clone(): CarCreateUpdate {
        const json = this.toJSON();
        let result = new CarCreateUpdate();
        result.init(json);
        return result;
    }
}

export interface ICarCreateUpdate {
    id?: number | undefined;
    number: string;
    height?: number | undefined;
    radius?: CarCreateUpdateRadius | undefined;
    is_active: boolean;
    brand: number;
    model: number;
    employees?: number[] | undefined;
}

export class _Employee implements I_Employee {
    phone?: string | undefined;
    email!: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    readonly id?: number | undefined;

    constructor(data?: I_Employee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.first_name = _data["first_name"];
            this.last_name = _data["last_name"];
            this.is_active = _data["is_active"];
            (<any>this).id = _data["id"];
        }
    }

    static fromJS(data: any, _mappings?: any): _Employee | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_Employee>(data, _mappings, _Employee);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["first_name"] = this.first_name;
        data["last_name"] = this.last_name;
        data["is_active"] = this.is_active;
        data["id"] = this.id;
        return data;
    }

    clone(): _Employee {
        const json = this.toJSON();
        let result = new _Employee();
        result.init(json);
        return result;
    }
}

export interface I_Employee {
    phone?: string | undefined;
    email: string;
    first_name?: string | undefined;
    last_name?: string | undefined;
    /** Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи. */
    is_active?: boolean | undefined;
    id?: number | undefined;
}

export class CarRetrieve implements ICarRetrieve {
    readonly id?: number | undefined;
    company?: Company | undefined;
    brand?: CarBrand | undefined;
    model?: CarModel | undefined;
    number!: string;
    is_active?: boolean | undefined;
    readonly employees?: _Employee[] | undefined;
    height?: number | undefined;
    radius?: CarRetrieveRadius | undefined;

    constructor(data?: ICarRetrieve) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.company = data.company && !(<any>data.company).toJSON ? new Company(data.company) : <Company>this.company;
            this.brand = data.brand && !(<any>data.brand).toJSON ? new CarBrand(data.brand) : <CarBrand>this.brand;
            this.model = data.model && !(<any>data.model).toJSON ? new CarModel(data.model) : <CarModel>this.model;
            if (data.employees) {
                this.employees = [];
                for (let i = 0; i < data.employees.length; i++) {
                    let item = data.employees[i];
                    this.employees[i] = item && !(<any>item).toJSON ? new _Employee(item) : <_Employee>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.company = _data["company"] ? Company.fromJS(_data["company"], _mappings) : <any>undefined;
            this.brand = _data["brand"] ? CarBrand.fromJS(_data["brand"], _mappings) : <any>undefined;
            this.model = _data["model"] ? CarModel.fromJS(_data["model"], _mappings) : <any>undefined;
            this.number = _data["number"];
            this.is_active = _data["is_active"];
            if (Array.isArray(_data["employees"])) {
                (<any>this).employees = [] as any;
                for (let item of _data["employees"])
                    (<any>this).employees!.push(_Employee.fromJS(item, _mappings));
            }
            this.height = _data["height"];
            this.radius = _data["radius"];
        }
    }

    static fromJS(data: any, _mappings?: any): CarRetrieve | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CarRetrieve>(data, _mappings, CarRetrieve);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        data["model"] = this.model ? this.model.toJSON() : <any>undefined;
        data["number"] = this.number;
        data["is_active"] = this.is_active;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        data["height"] = this.height;
        data["radius"] = this.radius;
        return data;
    }

    clone(): CarRetrieve {
        const json = this.toJSON();
        let result = new CarRetrieve();
        result.init(json);
        return result;
    }
}

export interface ICarRetrieve {
    id?: number | undefined;
    company?: ICompany | undefined;
    brand?: ICarBrand | undefined;
    model?: ICarModel | undefined;
    number: string;
    is_active?: boolean | undefined;
    employees?: I_Employee[] | undefined;
    height?: number | undefined;
    radius?: CarRetrieveRadius | undefined;
}

export class CarBrandsWithModels implements ICarBrandsWithModels {
    readonly id?: number | undefined;
    name!: string;
    car_models!: CarModel[];

    constructor(data?: ICarBrandsWithModels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.car_models) {
                this.car_models = [];
                for (let i = 0; i < data.car_models.length; i++) {
                    let item = data.car_models[i];
                    this.car_models[i] = item && !(<any>item).toJSON ? new CarModel(item) : <CarModel>item;
                }
            }
        }
        if (!data) {
            this.car_models = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["car_models"])) {
                this.car_models = [] as any;
                for (let item of _data["car_models"])
                    this.car_models!.push(CarModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CarBrandsWithModels | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CarBrandsWithModels>(data, _mappings, CarBrandsWithModels);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.car_models)) {
            data["car_models"] = [];
            for (let item of this.car_models)
                data["car_models"].push(item.toJSON());
        }
        return data;
    }

    clone(): CarBrandsWithModels {
        const json = this.toJSON();
        let result = new CarBrandsWithModels();
        result.init(json);
        return result;
    }
}

export interface ICarBrandsWithModels {
    id?: number | undefined;
    name: string;
    car_models: ICarModel[];
}

export class CarModelNewBrand implements ICarModelNewBrand {
    readonly id?: number | undefined;
    name!: string;
    car_type?: CarModelNewBrandCar_type | undefined;
    brand_name!: string;

    constructor(data?: ICarModelNewBrand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.car_type = _data["car_type"];
            this.brand_name = _data["brand_name"];
        }
    }

    static fromJS(data: any, _mappings?: any): CarModelNewBrand | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CarModelNewBrand>(data, _mappings, CarModelNewBrand);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["car_type"] = this.car_type;
        data["brand_name"] = this.brand_name;
        return data;
    }

    clone(): CarModelNewBrand {
        const json = this.toJSON();
        let result = new CarModelNewBrand();
        result.init(json);
        return result;
    }
}

export interface ICarModelNewBrand {
    id?: number | undefined;
    name: string;
    car_type?: CarModelNewBrandCar_type | undefined;
    brand_name: string;
}

export class CarModelRetrieve implements ICarModelRetrieve {
    readonly id?: number | undefined;
    name!: string;
    car_type?: CarModelRetrieveCar_type | undefined;
    brand!: CarBrand;

    constructor(data?: ICarModelRetrieve) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.brand = data.brand && !(<any>data.brand).toJSON ? new CarBrand(data.brand) : <CarBrand>this.brand;
        }
        if (!data) {
            this.brand = new CarBrand();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.car_type = _data["car_type"];
            this.brand = _data["brand"] ? CarBrand.fromJS(_data["brand"], _mappings) : new CarBrand();
        }
    }

    static fromJS(data: any, _mappings?: any): CarModelRetrieve | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CarModelRetrieve>(data, _mappings, CarModelRetrieve);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["car_type"] = this.car_type;
        data["brand"] = this.brand ? this.brand.toJSON() : <any>undefined;
        return data;
    }

    clone(): CarModelRetrieve {
        const json = this.toJSON();
        let result = new CarModelRetrieve();
        result.init(json);
        return result;
    }
}

export interface ICarModelRetrieve {
    id?: number | undefined;
    name: string;
    car_type?: CarModelRetrieveCar_type | undefined;
    brand: ICarBrand;
}

export class City implements ICity {
    readonly id?: number | undefined;
    name!: string;
    is_active?: boolean | undefined;
    timezone?: string | undefined;

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.is_active = _data["is_active"];
            this.timezone = _data["timezone"];
        }
    }

    static fromJS(data: any, _mappings?: any): City | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<City>(data, _mappings, City);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_active"] = this.is_active;
        data["timezone"] = this.timezone;
        return data;
    }

    clone(): City {
        const json = this.toJSON();
        let result = new City();
        result.init(json);
        return result;
    }
}

export interface ICity {
    id?: number | undefined;
    name: string;
    is_active?: boolean | undefined;
    timezone?: string | undefined;
}

export class ServiceOption implements IServiceOption {
    readonly id?: number | undefined;
    name!: string;
    is_active?: boolean | undefined;
    service_subtype!: number;

    constructor(data?: IServiceOption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.is_active = _data["is_active"];
            this.service_subtype = _data["service_subtype"];
        }
    }

    static fromJS(data: any, _mappings?: any): ServiceOption | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ServiceOption>(data, _mappings, ServiceOption);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_active"] = this.is_active;
        data["service_subtype"] = this.service_subtype;
        return data;
    }

    clone(): ServiceOption {
        const json = this.toJSON();
        let result = new ServiceOption();
        result.init(json);
        return result;
    }
}

export interface IServiceOption {
    id?: number | undefined;
    name: string;
    is_active?: boolean | undefined;
    service_subtype: number;
}

export class ServiceSubtype implements IServiceSubtype {
    readonly id?: number | undefined;
    name!: string;
    in_price?: boolean | undefined;
    readonly options?: ServiceOption[] | undefined;
    is_active?: boolean | undefined;

    constructor(data?: IServiceSubtype) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.options) {
                this.options = [];
                for (let i = 0; i < data.options.length; i++) {
                    let item = data.options[i];
                    this.options[i] = item && !(<any>item).toJSON ? new ServiceOption(item) : <ServiceOption>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.in_price = _data["in_price"];
            if (Array.isArray(_data["options"])) {
                (<any>this).options = [] as any;
                for (let item of _data["options"])
                    (<any>this).options!.push(ServiceOption.fromJS(item, _mappings));
            }
            this.is_active = _data["is_active"];
        }
    }

    static fromJS(data: any, _mappings?: any): ServiceSubtype | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ServiceSubtype>(data, _mappings, ServiceSubtype);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["in_price"] = this.in_price;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["is_active"] = this.is_active;
        return data;
    }

    clone(): ServiceSubtype {
        const json = this.toJSON();
        let result = new ServiceSubtype();
        result.init(json);
        return result;
    }
}

export interface IServiceSubtype {
    id?: number | undefined;
    name: string;
    in_price?: boolean | undefined;
    options?: IServiceOption[] | undefined;
    is_active?: boolean | undefined;
}

export class ServiceType implements IServiceType {
    readonly id?: number | undefined;
    name!: string;
    readonly subtypes?: ServiceSubtype[] | undefined;
    is_active?: boolean | undefined;

    constructor(data?: IServiceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.subtypes) {
                this.subtypes = [];
                for (let i = 0; i < data.subtypes.length; i++) {
                    let item = data.subtypes[i];
                    this.subtypes[i] = item && !(<any>item).toJSON ? new ServiceSubtype(item) : <ServiceSubtype>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["subtypes"])) {
                (<any>this).subtypes = [] as any;
                for (let item of _data["subtypes"])
                    (<any>this).subtypes!.push(ServiceSubtype.fromJS(item, _mappings));
            }
            this.is_active = _data["is_active"];
        }
    }

    static fromJS(data: any, _mappings?: any): ServiceType | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ServiceType>(data, _mappings, ServiceType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.subtypes)) {
            data["subtypes"] = [];
            for (let item of this.subtypes)
                data["subtypes"].push(item.toJSON());
        }
        data["is_active"] = this.is_active;
        return data;
    }

    clone(): ServiceType {
        const json = this.toJSON();
        let result = new ServiceType();
        result.init(json);
        return result;
    }
}

export interface IServiceType {
    id?: number | undefined;
    name: string;
    subtypes?: IServiceSubtype[] | undefined;
    is_active?: boolean | undefined;
}

export class ServiceSubtypeCreate implements IServiceSubtypeCreate {
    readonly id?: number | undefined;
    name!: string;
    is_active?: boolean | undefined;
    service_type!: number;

    constructor(data?: IServiceSubtypeCreate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.is_active = _data["is_active"];
            this.service_type = _data["service_type"];
        }
    }

    static fromJS(data: any, _mappings?: any): ServiceSubtypeCreate | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<ServiceSubtypeCreate>(data, _mappings, ServiceSubtypeCreate);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["is_active"] = this.is_active;
        data["service_type"] = this.service_type;
        return data;
    }

    clone(): ServiceSubtypeCreate {
        const json = this.toJSON();
        let result = new ServiceSubtypeCreate();
        result.init(json);
        return result;
    }
}

export interface IServiceSubtypeCreate {
    id?: number | undefined;
    name: string;
    is_active?: boolean | undefined;
    service_type: number;
}

export class _CustomerProfile implements I_CustomerProfile {
    readonly id?: number | undefined;
    address!: string;
    inn?: string | undefined;
    ogrn?: string | undefined;
    legal_address?: string | undefined;
    contacts?: string | undefined;
    overdraft?: boolean | undefined;
    overdraft_sum?: number | undefined;
    performer_company?: number[] | undefined;
    lat!: number;
    lon!: number;

    constructor(data?: I_CustomerProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.address = _data["address"];
            this.inn = _data["inn"];
            this.ogrn = _data["ogrn"];
            this.legal_address = _data["legal_address"];
            this.contacts = _data["contacts"];
            this.overdraft = _data["overdraft"];
            this.overdraft_sum = _data["overdraft_sum"];
            if (Array.isArray(_data["performer_company"])) {
                this.performer_company = [] as any;
                for (let item of _data["performer_company"])
                    this.performer_company!.push(item);
            }
            this.lat = _data["lat"];
            this.lon = _data["lon"];
        }
    }

    static fromJS(data: any, _mappings?: any): _CustomerProfile | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_CustomerProfile>(data, _mappings, _CustomerProfile);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        data["inn"] = this.inn;
        data["ogrn"] = this.ogrn;
        data["legal_address"] = this.legal_address;
        data["contacts"] = this.contacts;
        data["overdraft"] = this.overdraft;
        data["overdraft_sum"] = this.overdraft_sum;
        if (Array.isArray(this.performer_company)) {
            data["performer_company"] = [];
            for (let item of this.performer_company)
                data["performer_company"].push(item);
        }
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data;
    }

    clone(): _CustomerProfile {
        const json = this.toJSON();
        let result = new _CustomerProfile();
        result.init(json);
        return result;
    }
}

export interface I_CustomerProfile {
    id?: number | undefined;
    address: string;
    inn?: string | undefined;
    ogrn?: string | undefined;
    legal_address?: string | undefined;
    contacts?: string | undefined;
    overdraft?: boolean | undefined;
    overdraft_sum?: number | undefined;
    performer_company?: number[] | undefined;
    lat: number;
    lon: number;
}

export class CustomerCompany implements ICustomerCompany {
    readonly id?: number | undefined;
    name!: string;
    city!: number;
    is_active?: boolean | undefined;
    customerprofile!: _CustomerProfile;

    constructor(data?: ICustomerCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.customerprofile = data.customerprofile && !(<any>data.customerprofile).toJSON ? new _CustomerProfile(data.customerprofile) : <_CustomerProfile>this.customerprofile;
        }
        if (!data) {
            this.customerprofile = new _CustomerProfile();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"];
            this.is_active = _data["is_active"];
            this.customerprofile = _data["customerprofile"] ? _CustomerProfile.fromJS(_data["customerprofile"], _mappings) : new _CustomerProfile();
        }
    }

    static fromJS(data: any, _mappings?: any): CustomerCompany | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomerCompany>(data, _mappings, CustomerCompany);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city;
        data["is_active"] = this.is_active;
        data["customerprofile"] = this.customerprofile ? this.customerprofile.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerCompany {
        const json = this.toJSON();
        let result = new CustomerCompany();
        result.init(json);
        return result;
    }
}

export interface ICustomerCompany {
    id?: number | undefined;
    name: string;
    city: number;
    is_active?: boolean | undefined;
    customerprofile: I_CustomerProfile;
}

export class _Balance implements I_Balance {
    readonly id?: number | undefined;
    total!: number;

    constructor(data?: I_Balance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any, _mappings?: any): _Balance | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_Balance>(data, _mappings, _Balance);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["total"] = this.total;
        return data;
    }

    clone(): _Balance {
        const json = this.toJSON();
        let result = new _Balance();
        result.init(json);
        return result;
    }
}

export interface I_Balance {
    id?: number | undefined;
    total: number;
}

export class GetCustomerCompany implements IGetCustomerCompany {
    readonly id?: number | undefined;
    name!: string;
    city!: _City;
    balance!: _Balance;
    is_active?: boolean | undefined;
    customerprofile!: _CustomerProfile;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    parent!: _Parent;

    constructor(data?: IGetCustomerCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.city = data.city && !(<any>data.city).toJSON ? new _City(data.city) : <_City>this.city;
            this.balance = data.balance && !(<any>data.balance).toJSON ? new _Balance(data.balance) : <_Balance>this.balance;
            this.customerprofile = data.customerprofile && !(<any>data.customerprofile).toJSON ? new _CustomerProfile(data.customerprofile) : <_CustomerProfile>this.customerprofile;
            this.parent = data.parent && !(<any>data.parent).toJSON ? new _Parent(data.parent) : <_Parent>this.parent;
        }
        if (!data) {
            this.city = new _City();
            this.balance = new _Balance();
            this.customerprofile = new _CustomerProfile();
            this.parent = new _Parent();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"] ? _City.fromJS(_data["city"], _mappings) : new _City();
            this.balance = _data["balance"] ? _Balance.fromJS(_data["balance"], _mappings) : new _Balance();
            this.is_active = _data["is_active"];
            this.customerprofile = _data["customerprofile"] ? _CustomerProfile.fromJS(_data["customerprofile"], _mappings) : new _CustomerProfile();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.parent = _data["parent"] ? _Parent.fromJS(_data["parent"], _mappings) : new _Parent();
        }
    }

    static fromJS(data: any, _mappings?: any): GetCustomerCompany | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetCustomerCompany>(data, _mappings, GetCustomerCompany);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["is_active"] = this.is_active;
        data["customerprofile"] = this.customerprofile ? this.customerprofile.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCustomerCompany {
        const json = this.toJSON();
        let result = new GetCustomerCompany();
        result.init(json);
        return result;
    }
}

export interface IGetCustomerCompany {
    id?: number | undefined;
    name: string;
    city: I_City;
    balance: I_Balance;
    is_active?: boolean | undefined;
    customerprofile: I_CustomerProfile;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    parent: I_Parent;
}

export class _PerformerProfile implements I_PerformerProfile {
    readonly id?: number | undefined;
    address!: string;
    inn?: string | undefined;
    ogrn?: string | undefined;
    legal_address?: string | undefined;
    contacts?: string | undefined;
    service_percent!: number;
    working_time?: string | undefined;
    height?: number | undefined;
    lat!: number;
    lon!: number;

    constructor(data?: I_PerformerProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.address = _data["address"];
            this.inn = _data["inn"];
            this.ogrn = _data["ogrn"];
            this.legal_address = _data["legal_address"];
            this.contacts = _data["contacts"];
            this.service_percent = _data["service_percent"];
            this.working_time = _data["working_time"];
            this.height = _data["height"];
            this.lat = _data["lat"];
            this.lon = _data["lon"];
        }
    }

    static fromJS(data: any, _mappings?: any): _PerformerProfile | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_PerformerProfile>(data, _mappings, _PerformerProfile);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        data["inn"] = this.inn;
        data["ogrn"] = this.ogrn;
        data["legal_address"] = this.legal_address;
        data["contacts"] = this.contacts;
        data["service_percent"] = this.service_percent;
        data["working_time"] = this.working_time;
        data["height"] = this.height;
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        return data;
    }

    clone(): _PerformerProfile {
        const json = this.toJSON();
        let result = new _PerformerProfile();
        result.init(json);
        return result;
    }
}

export interface I_PerformerProfile {
    id?: number | undefined;
    address: string;
    inn?: string | undefined;
    ogrn?: string | undefined;
    legal_address?: string | undefined;
    contacts?: string | undefined;
    service_percent: number;
    working_time?: string | undefined;
    height?: number | undefined;
    lat: number;
    lon: number;
}

export class PerformerCompany implements IPerformerCompany {
    readonly id?: number | undefined;
    name!: string;
    city!: number;
    is_active?: boolean | undefined;
    performerprofile!: _PerformerProfile;

    constructor(data?: IPerformerCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.performerprofile = data.performerprofile && !(<any>data.performerprofile).toJSON ? new _PerformerProfile(data.performerprofile) : <_PerformerProfile>this.performerprofile;
        }
        if (!data) {
            this.performerprofile = new _PerformerProfile();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"];
            this.is_active = _data["is_active"];
            this.performerprofile = _data["performerprofile"] ? _PerformerProfile.fromJS(_data["performerprofile"], _mappings) : new _PerformerProfile();
        }
    }

    static fromJS(data: any, _mappings?: any): PerformerCompany | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PerformerCompany>(data, _mappings, PerformerCompany);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city;
        data["is_active"] = this.is_active;
        data["performerprofile"] = this.performerprofile ? this.performerprofile.toJSON() : <any>undefined;
        return data;
    }

    clone(): PerformerCompany {
        const json = this.toJSON();
        let result = new PerformerCompany();
        result.init(json);
        return result;
    }
}

export interface IPerformerCompany {
    id?: number | undefined;
    name: string;
    city: number;
    is_active?: boolean | undefined;
    performerprofile: I_PerformerProfile;
}

export class GetPerformerCompany implements IGetPerformerCompany {
    readonly id?: number | undefined;
    name!: string;
    city!: _City;
    balance!: _Balance;
    is_active?: boolean | undefined;
    performerprofile!: _PerformerProfile;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    parent!: _Parent;
    readonly active_services?: string | undefined;

    constructor(data?: IGetPerformerCompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.city = data.city && !(<any>data.city).toJSON ? new _City(data.city) : <_City>this.city;
            this.balance = data.balance && !(<any>data.balance).toJSON ? new _Balance(data.balance) : <_Balance>this.balance;
            this.performerprofile = data.performerprofile && !(<any>data.performerprofile).toJSON ? new _PerformerProfile(data.performerprofile) : <_PerformerProfile>this.performerprofile;
            this.parent = data.parent && !(<any>data.parent).toJSON ? new _Parent(data.parent) : <_Parent>this.parent;
        }
        if (!data) {
            this.city = new _City();
            this.balance = new _Balance();
            this.performerprofile = new _PerformerProfile();
            this.parent = new _Parent();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"] ? _City.fromJS(_data["city"], _mappings) : new _City();
            this.balance = _data["balance"] ? _Balance.fromJS(_data["balance"], _mappings) : new _Balance();
            this.is_active = _data["is_active"];
            this.performerprofile = _data["performerprofile"] ? _PerformerProfile.fromJS(_data["performerprofile"], _mappings) : new _PerformerProfile();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.parent = _data["parent"] ? _Parent.fromJS(_data["parent"], _mappings) : new _Parent();
            (<any>this).active_services = _data["active_services"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetPerformerCompany | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetPerformerCompany>(data, _mappings, GetPerformerCompany);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["is_active"] = this.is_active;
        data["performerprofile"] = this.performerprofile ? this.performerprofile.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["active_services"] = this.active_services;
        return data;
    }

    clone(): GetPerformerCompany {
        const json = this.toJSON();
        let result = new GetPerformerCompany();
        result.init(json);
        return result;
    }
}

export interface IGetPerformerCompany {
    id?: number | undefined;
    name: string;
    city: I_City;
    balance: I_Balance;
    is_active?: boolean | undefined;
    performerprofile: I_PerformerProfile;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    parent: I_Parent;
    active_services?: string | undefined;
}

export class CustomerBranch implements ICustomerBranch {
    readonly id?: number | undefined;
    name!: string;
    city!: number;
    is_active?: boolean | undefined;
    customerprofile!: _CustomerProfile;

    constructor(data?: ICustomerBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.customerprofile = data.customerprofile && !(<any>data.customerprofile).toJSON ? new _CustomerProfile(data.customerprofile) : <_CustomerProfile>this.customerprofile;
        }
        if (!data) {
            this.customerprofile = new _CustomerProfile();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"];
            this.is_active = _data["is_active"];
            this.customerprofile = _data["customerprofile"] ? _CustomerProfile.fromJS(_data["customerprofile"], _mappings) : new _CustomerProfile();
        }
    }

    static fromJS(data: any, _mappings?: any): CustomerBranch | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomerBranch>(data, _mappings, CustomerBranch);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city;
        data["is_active"] = this.is_active;
        data["customerprofile"] = this.customerprofile ? this.customerprofile.toJSON() : <any>undefined;
        return data;
    }

    clone(): CustomerBranch {
        const json = this.toJSON();
        let result = new CustomerBranch();
        result.init(json);
        return result;
    }
}

export interface ICustomerBranch {
    id?: number | undefined;
    name: string;
    city: number;
    is_active?: boolean | undefined;
    customerprofile: I_CustomerProfile;
}

export class GetCustomerBranch implements IGetCustomerBranch {
    readonly id?: number | undefined;
    name!: string;
    city!: _City;
    balance!: _Balance;
    is_active?: boolean | undefined;
    customerprofile!: _CustomerProfile;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    parent!: _Parent;

    constructor(data?: IGetCustomerBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.city = data.city && !(<any>data.city).toJSON ? new _City(data.city) : <_City>this.city;
            this.balance = data.balance && !(<any>data.balance).toJSON ? new _Balance(data.balance) : <_Balance>this.balance;
            this.customerprofile = data.customerprofile && !(<any>data.customerprofile).toJSON ? new _CustomerProfile(data.customerprofile) : <_CustomerProfile>this.customerprofile;
            this.parent = data.parent && !(<any>data.parent).toJSON ? new _Parent(data.parent) : <_Parent>this.parent;
        }
        if (!data) {
            this.city = new _City();
            this.balance = new _Balance();
            this.customerprofile = new _CustomerProfile();
            this.parent = new _Parent();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"] ? _City.fromJS(_data["city"], _mappings) : new _City();
            this.balance = _data["balance"] ? _Balance.fromJS(_data["balance"], _mappings) : new _Balance();
            this.is_active = _data["is_active"];
            this.customerprofile = _data["customerprofile"] ? _CustomerProfile.fromJS(_data["customerprofile"], _mappings) : new _CustomerProfile();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.parent = _data["parent"] ? _Parent.fromJS(_data["parent"], _mappings) : new _Parent();
        }
    }

    static fromJS(data: any, _mappings?: any): GetCustomerBranch | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetCustomerBranch>(data, _mappings, GetCustomerBranch);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["is_active"] = this.is_active;
        data["customerprofile"] = this.customerprofile ? this.customerprofile.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetCustomerBranch {
        const json = this.toJSON();
        let result = new GetCustomerBranch();
        result.init(json);
        return result;
    }
}

export interface IGetCustomerBranch {
    id?: number | undefined;
    name: string;
    city: I_City;
    balance: I_Balance;
    is_active?: boolean | undefined;
    customerprofile: I_CustomerProfile;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    parent: I_Parent;
}

export class Limit implements ILimit {
    readonly id?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    is_day?: boolean | undefined;
    is_active?: boolean | undefined;
    company!: number;
    city?: number | undefined;
    employee?: number | undefined;
    car?: number | undefined;
    service_type!: number;

    constructor(data?: ILimit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.is_day = _data["is_day"];
            this.is_active = _data["is_active"];
            this.company = _data["company"];
            this.city = _data["city"];
            this.employee = _data["employee"];
            this.car = _data["car"];
            this.service_type = _data["service_type"];
        }
    }

    static fromJS(data: any, _mappings?: any): Limit | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Limit>(data, _mappings, Limit);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["is_day"] = this.is_day;
        data["is_active"] = this.is_active;
        data["company"] = this.company;
        data["city"] = this.city;
        data["employee"] = this.employee;
        data["car"] = this.car;
        data["service_type"] = this.service_type;
        return data;
    }

    clone(): Limit {
        const json = this.toJSON();
        let result = new Limit();
        result.init(json);
        return result;
    }
}

export interface ILimit {
    id?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    is_day?: boolean | undefined;
    is_active?: boolean | undefined;
    company: number;
    city?: number | undefined;
    employee?: number | undefined;
    car?: number | undefined;
    service_type: number;
}

export class BranchPerformerProfile implements IBranchPerformerProfile {
    address!: string;
    working_time?: string | undefined;
    lat!: number;
    lon!: number;
    height?: number | undefined;

    constructor(data?: IBranchPerformerProfile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.address = _data["address"];
            this.working_time = _data["working_time"];
            this.lat = _data["lat"];
            this.lon = _data["lon"];
            this.height = _data["height"];
        }
    }

    static fromJS(data: any, _mappings?: any): BranchPerformerProfile | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<BranchPerformerProfile>(data, _mappings, BranchPerformerProfile);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["working_time"] = this.working_time;
        data["lat"] = this.lat;
        data["lon"] = this.lon;
        data["height"] = this.height;
        return data;
    }

    clone(): BranchPerformerProfile {
        const json = this.toJSON();
        let result = new BranchPerformerProfile();
        result.init(json);
        return result;
    }
}

export interface IBranchPerformerProfile {
    address: string;
    working_time?: string | undefined;
    lat: number;
    lon: number;
    height?: number | undefined;
}

export class PerformerBranch implements IPerformerBranch {
    readonly id?: number | undefined;
    name!: string;
    city!: number;
    is_active?: boolean | undefined;
    performerprofile!: BranchPerformerProfile;

    constructor(data?: IPerformerBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.performerprofile = data.performerprofile && !(<any>data.performerprofile).toJSON ? new BranchPerformerProfile(data.performerprofile) : <BranchPerformerProfile>this.performerprofile;
        }
        if (!data) {
            this.performerprofile = new BranchPerformerProfile();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"];
            this.is_active = _data["is_active"];
            this.performerprofile = _data["performerprofile"] ? BranchPerformerProfile.fromJS(_data["performerprofile"], _mappings) : new BranchPerformerProfile();
        }
    }

    static fromJS(data: any, _mappings?: any): PerformerBranch | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<PerformerBranch>(data, _mappings, PerformerBranch);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city;
        data["is_active"] = this.is_active;
        data["performerprofile"] = this.performerprofile ? this.performerprofile.toJSON() : <any>undefined;
        return data;
    }

    clone(): PerformerBranch {
        const json = this.toJSON();
        let result = new PerformerBranch();
        result.init(json);
        return result;
    }
}

export interface IPerformerBranch {
    id?: number | undefined;
    name: string;
    city: number;
    is_active?: boolean | undefined;
    performerprofile: IBranchPerformerProfile;
}

export class GetPerformerBranch implements IGetPerformerBranch {
    readonly id?: number | undefined;
    name!: string;
    city!: _City;
    balance!: _Balance;
    is_active?: boolean | undefined;
    performerprofile!: _PerformerProfile;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    parent!: _Parent;

    constructor(data?: IGetPerformerBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.city = data.city && !(<any>data.city).toJSON ? new _City(data.city) : <_City>this.city;
            this.balance = data.balance && !(<any>data.balance).toJSON ? new _Balance(data.balance) : <_Balance>this.balance;
            this.performerprofile = data.performerprofile && !(<any>data.performerprofile).toJSON ? new _PerformerProfile(data.performerprofile) : <_PerformerProfile>this.performerprofile;
            this.parent = data.parent && !(<any>data.parent).toJSON ? new _Parent(data.parent) : <_Parent>this.parent;
        }
        if (!data) {
            this.city = new _City();
            this.balance = new _Balance();
            this.performerprofile = new _PerformerProfile();
            this.parent = new _Parent();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.city = _data["city"] ? _City.fromJS(_data["city"], _mappings) : new _City();
            this.balance = _data["balance"] ? _Balance.fromJS(_data["balance"], _mappings) : new _Balance();
            this.is_active = _data["is_active"];
            this.performerprofile = _data["performerprofile"] ? _PerformerProfile.fromJS(_data["performerprofile"], _mappings) : new _PerformerProfile();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.parent = _data["parent"] ? _Parent.fromJS(_data["parent"], _mappings) : new _Parent();
        }
    }

    static fromJS(data: any, _mappings?: any): GetPerformerBranch | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetPerformerBranch>(data, _mappings, GetPerformerBranch);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["balance"] = this.balance ? this.balance.toJSON() : <any>undefined;
        data["is_active"] = this.is_active;
        data["performerprofile"] = this.performerprofile ? this.performerprofile.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetPerformerBranch {
        const json = this.toJSON();
        let result = new GetPerformerBranch();
        result.init(json);
        return result;
    }
}

export interface IGetPerformerBranch {
    id?: number | undefined;
    name: string;
    city: I_City;
    balance: I_Balance;
    is_active?: boolean | undefined;
    performerprofile: I_PerformerProfile;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    parent: I_Parent;
}

export class AllWithPrices implements IAllWithPrices {
    readonly id?: number | undefined;
    name!: string;
    company_type?: AllWithPricesCompany_type | undefined;
    readonly root_company?: string | undefined;

    constructor(data?: IAllWithPrices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.name = _data["name"];
            this.company_type = _data["company_type"];
            (<any>this).root_company = _data["root_company"];
        }
    }

    static fromJS(data: any, _mappings?: any): AllWithPrices | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<AllWithPrices>(data, _mappings, AllWithPrices);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["company_type"] = this.company_type;
        data["root_company"] = this.root_company;
        return data;
    }

    clone(): AllWithPrices {
        const json = this.toJSON();
        let result = new AllWithPrices();
        result.init(json);
        return result;
    }
}

export interface IAllWithPrices {
    id?: number | undefined;
    name: string;
    company_type?: AllWithPricesCompany_type | undefined;
    root_company?: string | undefined;
}

export class _SubType implements I_SubType {
    readonly id?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    name!: string;
    is_common?: boolean | undefined;
    in_price?: boolean | undefined;
    is_active?: boolean | undefined;
    service_type!: number;

    constructor(data?: I_SubType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.is_common = _data["is_common"];
            this.in_price = _data["in_price"];
            this.is_active = _data["is_active"];
            this.service_type = _data["service_type"];
        }
    }

    static fromJS(data: any, _mappings?: any): _SubType | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_SubType>(data, _mappings, _SubType);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["is_common"] = this.is_common;
        data["in_price"] = this.in_price;
        data["is_active"] = this.is_active;
        data["service_type"] = this.service_type;
        return data;
    }

    clone(): _SubType {
        const json = this.toJSON();
        let result = new _SubType();
        result.init(json);
        return result;
    }
}

export interface I_SubType {
    id?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    name: string;
    is_common?: boolean | undefined;
    in_price?: boolean | undefined;
    is_active?: boolean | undefined;
    service_type: number;
}

export class _Option implements I_Option {
    readonly id?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    name!: string;
    is_common?: boolean | undefined;
    is_active?: boolean | undefined;
    service_subtype!: number;

    constructor(data?: I_Option) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.is_common = _data["is_common"];
            this.is_active = _data["is_active"];
            this.service_subtype = _data["service_subtype"];
        }
    }

    static fromJS(data: any, _mappings?: any): _Option | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_Option>(data, _mappings, _Option);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["is_common"] = this.is_common;
        data["is_active"] = this.is_active;
        data["service_subtype"] = this.service_subtype;
        return data;
    }

    clone(): _Option {
        const json = this.toJSON();
        let result = new _Option();
        result.init(json);
        return result;
    }
}

export interface I_Option {
    id?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    name: string;
    is_common?: boolean | undefined;
    is_active?: boolean | undefined;
    service_subtype: number;
}

export class _EvacuationPosition implements I_EvacuationPosition {
    readonly id?: number | undefined;
    service_subtype!: _SubType;
    service_option!: _Option;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    price!: number;

    constructor(data?: I_EvacuationPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.service_subtype = data.service_subtype && !(<any>data.service_subtype).toJSON ? new _SubType(data.service_subtype) : <_SubType>this.service_subtype;
            this.service_option = data.service_option && !(<any>data.service_option).toJSON ? new _Option(data.service_option) : <_Option>this.service_option;
        }
        if (!data) {
            this.service_subtype = new _SubType();
            this.service_option = new _Option();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.service_subtype = _data["service_subtype"] ? _SubType.fromJS(_data["service_subtype"], _mappings) : new _SubType();
            this.service_option = _data["service_option"] ? _Option.fromJS(_data["service_option"], _mappings) : new _Option();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any, _mappings?: any): _EvacuationPosition | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_EvacuationPosition>(data, _mappings, _EvacuationPosition);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["service_subtype"] = this.service_subtype ? this.service_subtype.toJSON() : <any>undefined;
        data["service_option"] = this.service_option ? this.service_option.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["price"] = this.price;
        return data;
    }

    clone(): _EvacuationPosition {
        const json = this.toJSON();
        let result = new _EvacuationPosition();
        result.init(json);
        return result;
    }
}

export interface I_EvacuationPosition {
    id?: number | undefined;
    service_subtype: I_SubType;
    service_option: I_Option;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    price: number;
}

export class GetEvacuationPrice implements IGetEvacuationPrice {
    readonly id?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    company!: number;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;
    readonly evacuation_positions?: _EvacuationPosition[] | undefined;

    constructor(data?: IGetEvacuationPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.evacuation_positions) {
                this.evacuation_positions = [];
                for (let i = 0; i < data.evacuation_positions.length; i++) {
                    let item = data.evacuation_positions[i];
                    this.evacuation_positions[i] = item && !(<any>item).toJSON ? new _EvacuationPosition(item) : <_EvacuationPosition>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            this.company = _data["company"];
            this.expires = _data["expires"] ? dayjs(_data["expires"].toString()) : <any>undefined;
            this.is_active = _data["is_active"];
            if (Array.isArray(_data["evacuation_positions"])) {
                (<any>this).evacuation_positions = [] as any;
                for (let item of _data["evacuation_positions"])
                    (<any>this).evacuation_positions!.push(_EvacuationPosition.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): GetEvacuationPrice | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetEvacuationPrice>(data, _mappings, GetEvacuationPrice);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["company"] = this.company;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["is_active"] = this.is_active;
        if (Array.isArray(this.evacuation_positions)) {
            data["evacuation_positions"] = [];
            for (let item of this.evacuation_positions)
                data["evacuation_positions"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetEvacuationPrice {
        const json = this.toJSON();
        let result = new GetEvacuationPrice();
        result.init(json);
        return result;
    }
}

export interface IGetEvacuationPrice {
    id?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    company: number;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;
    evacuation_positions?: I_EvacuationPosition[] | undefined;
}

export class _TirePosition implements I_TirePosition {
    readonly id?: number | undefined;
    service_subtype!: _SubType;
    service_option!: _Option;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    radius?: _TirePositionRadius | undefined;
    car_type?: _TirePositionCar_type | undefined;
    price!: number;

    constructor(data?: I_TirePosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.service_subtype = data.service_subtype && !(<any>data.service_subtype).toJSON ? new _SubType(data.service_subtype) : <_SubType>this.service_subtype;
            this.service_option = data.service_option && !(<any>data.service_option).toJSON ? new _Option(data.service_option) : <_Option>this.service_option;
        }
        if (!data) {
            this.service_subtype = new _SubType();
            this.service_option = new _Option();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.service_subtype = _data["service_subtype"] ? _SubType.fromJS(_data["service_subtype"], _mappings) : new _SubType();
            this.service_option = _data["service_option"] ? _Option.fromJS(_data["service_option"], _mappings) : new _Option();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.radius = _data["radius"];
            this.car_type = _data["car_type"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any, _mappings?: any): _TirePosition | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_TirePosition>(data, _mappings, _TirePosition);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["service_subtype"] = this.service_subtype ? this.service_subtype.toJSON() : <any>undefined;
        data["service_option"] = this.service_option ? this.service_option.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["radius"] = this.radius;
        data["car_type"] = this.car_type;
        data["price"] = this.price;
        return data;
    }

    clone(): _TirePosition {
        const json = this.toJSON();
        let result = new _TirePosition();
        result.init(json);
        return result;
    }
}

export interface I_TirePosition {
    id?: number | undefined;
    service_subtype: I_SubType;
    service_option: I_Option;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    radius?: _TirePositionRadius | undefined;
    car_type?: _TirePositionCar_type | undefined;
    price: number;
}

export class GetTirePrice implements IGetTirePrice {
    readonly id?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    company!: number;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;
    readonly tire_positions?: _TirePosition[] | undefined;

    constructor(data?: IGetTirePrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.tire_positions) {
                this.tire_positions = [];
                for (let i = 0; i < data.tire_positions.length; i++) {
                    let item = data.tire_positions[i];
                    this.tire_positions[i] = item && !(<any>item).toJSON ? new _TirePosition(item) : <_TirePosition>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            this.company = _data["company"];
            this.expires = _data["expires"] ? dayjs(_data["expires"].toString()) : <any>undefined;
            this.is_active = _data["is_active"];
            if (Array.isArray(_data["tire_positions"])) {
                (<any>this).tire_positions = [] as any;
                for (let item of _data["tire_positions"])
                    (<any>this).tire_positions!.push(_TirePosition.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): GetTirePrice | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetTirePrice>(data, _mappings, GetTirePrice);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["company"] = this.company;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["is_active"] = this.is_active;
        if (Array.isArray(this.tire_positions)) {
            data["tire_positions"] = [];
            for (let item of this.tire_positions)
                data["tire_positions"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetTirePrice {
        const json = this.toJSON();
        let result = new GetTirePrice();
        result.init(json);
        return result;
    }
}

export interface IGetTirePrice {
    id?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    company: number;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;
    tire_positions?: I_TirePosition[] | undefined;
}

export class _WashPosition implements I_WashPosition {
    readonly id?: number | undefined;
    service_subtype!: _SubType | null;
    service_option!: _Option | null;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    car_class?: _WashPositionCar_class | undefined;
    price!: number;

    constructor(data?: I_WashPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.service_subtype = data.service_subtype && !(<any>data.service_subtype).toJSON ? new _SubType(data.service_subtype) : <_SubType>this.service_subtype;
            this.service_option = data.service_option && !(<any>data.service_option).toJSON ? new _Option(data.service_option) : <_Option>this.service_option;
        }
        if (!data) {
            this.service_subtype = new _SubType();
            this.service_option = new _Option();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.service_subtype = _data["service_subtype"] ? _SubType.fromJS(_data["service_subtype"], _mappings) : new _SubType();
            this.service_option = _data["service_option"] ? _Option.fromJS(_data["service_option"], _mappings) : new _Option();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.car_class = _data["car_class"];
            this.price = _data["price"];
        }
    }

    static fromJS(data: any, _mappings?: any): _WashPosition | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<_WashPosition>(data, _mappings, _WashPosition);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["service_subtype"] = this.service_subtype ? this.service_subtype.toJSON() : <any>undefined;
        data["service_option"] = this.service_option ? this.service_option.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["car_class"] = this.car_class;
        data["price"] = this.price;
        return data;
    }

    clone(): _WashPosition {
        const json = this.toJSON();
        let result = new _WashPosition();
        result.init(json);
        return result;
    }
}

export interface I_WashPosition {
    id?: number | undefined;
    service_subtype: I_SubType;
    service_option: I_Option;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    amount?: number | undefined;
    car_class?: _WashPositionCar_class | undefined;
    price: number;
}

export class GetWashPrice implements IGetWashPrice {
    readonly id?: number | undefined;
    readonly created?: dayjs.Dayjs | undefined;
    company!: number;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;
    readonly wash_positions?: _WashPosition[] | undefined;

    constructor(data?: IGetWashPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.wash_positions) {
                this.wash_positions = [];
                for (let i = 0; i < data.wash_positions.length; i++) {
                    let item = data.wash_positions[i];
                    this.wash_positions[i] = item && !(<any>item).toJSON ? new _WashPosition(item) : <_WashPosition>item;
                }
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            this.company = _data["company"];
            this.expires = _data["expires"] ? dayjs(_data["expires"].toString()) : <any>undefined;
            this.is_active = _data["is_active"];
            if (Array.isArray(_data["wash_positions"])) {
                (<any>this).wash_positions = [] as any;
                for (let item of _data["wash_positions"])
                    (<any>this).wash_positions!.push(_WashPosition.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): GetWashPrice | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetWashPrice>(data, _mappings, GetWashPrice);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["company"] = this.company;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["is_active"] = this.is_active;
        if (Array.isArray(this.wash_positions)) {
            data["wash_positions"] = [];
            for (let item of this.wash_positions)
                data["wash_positions"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetWashPrice {
        const json = this.toJSON();
        let result = new GetWashPrice();
        result.init(json);
        return result;
    }
}

export interface IGetWashPrice {
    id?: number | undefined;
    created?: dayjs.Dayjs | undefined;
    company: number;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;
    wash_positions?: I_WashPosition[] | undefined;
}

export class GetHistoryPrice implements IGetHistoryPrice {
    readonly id?: number | undefined;
    service_type!: _ServiceType;
    company!: Company;
    readonly created?: dayjs.Dayjs | undefined;
    readonly updated?: dayjs.Dayjs | undefined;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;

    constructor(data?: IGetHistoryPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.service_type = data.service_type && !(<any>data.service_type).toJSON ? new _ServiceType(data.service_type) : <_ServiceType>this.service_type;
            this.company = data.company && !(<any>data.company).toJSON ? new Company(data.company) : <Company>this.company;
        }
        if (!data) {
            this.service_type = new _ServiceType();
            this.company = new Company();
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            (<any>this).id = _data["id"];
            this.service_type = _data["service_type"] ? _ServiceType.fromJS(_data["service_type"], _mappings) : new _ServiceType();
            this.company = _data["company"] ? Company.fromJS(_data["company"], _mappings) : new Company();
            (<any>this).created = _data["created"] ? dayjs(_data["created"].toString()) : <any>undefined;
            (<any>this).updated = _data["updated"] ? dayjs(_data["updated"].toString()) : <any>undefined;
            this.expires = _data["expires"] ? dayjs(_data["expires"].toString()) : <any>undefined;
            this.is_active = _data["is_active"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetHistoryPrice | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetHistoryPrice>(data, _mappings, GetHistoryPrice);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["service_type"] = this.service_type ? this.service_type.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["is_active"] = this.is_active;
        return data;
    }

    clone(): GetHistoryPrice {
        const json = this.toJSON();
        let result = new GetHistoryPrice();
        result.init(json);
        return result;
    }
}

export interface IGetHistoryPrice {
    id?: number | undefined;
    service_type: I_ServiceType;
    company: ICompany;
    created?: dayjs.Dayjs | undefined;
    updated?: dayjs.Dayjs | undefined;
    expires?: dayjs.Dayjs | undefined;
    is_active?: boolean | undefined;
}

export class CreateNewPrice implements ICreateNewPrice {
    positions!: { [key: string]: string; };

    constructor(data?: ICreateNewPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.positions = {};
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (_data["positions"]) {
                this.positions = {} as any;
                for (let key in _data["positions"]) {
                    if (_data["positions"].hasOwnProperty(key))
                        (<any>this.positions)![key] = _data["positions"][key];
                }
            }
        }
    }

    static fromJS(data: any, _mappings?: any): CreateNewPrice | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateNewPrice>(data, _mappings, CreateNewPrice);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.positions) {
            data["positions"] = {};
            for (let key in this.positions) {
                if (this.positions.hasOwnProperty(key))
                    (<any>data["positions"])[key] = (<any>this.positions)[key];
            }
        }
        return data;
    }

    clone(): CreateNewPrice {
        const json = this.toJSON();
        let result = new CreateNewPrice();
        result.init(json);
        return result;
    }
}

export interface ICreateNewPrice {
    positions: { [key: string]: string; };
}

export class CustomTokenObtainPair implements ICustomTokenObtainPair {
    email!: string;
    password!: string;

    constructor(data?: ICustomTokenObtainPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any, _mappings?: any): CustomTokenObtainPair | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<CustomTokenObtainPair>(data, _mappings, CustomTokenObtainPair);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }

    clone(): CustomTokenObtainPair {
        const json = this.toJSON();
        let result = new CustomTokenObtainPair();
        result.init(json);
        return result;
    }
}

export interface ICustomTokenObtainPair {
    email: string;
    password: string;
}

export class TokenRefresh implements ITokenRefresh {
    refresh!: string;
    readonly access?: string | undefined;

    constructor(data?: ITokenRefresh) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.refresh = _data["refresh"];
            (<any>this).access = _data["access"];
        }
    }

    static fromJS(data: any, _mappings?: any): TokenRefresh | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<TokenRefresh>(data, _mappings, TokenRefresh);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refresh"] = this.refresh;
        data["access"] = this.access;
        return data;
    }

    clone(): TokenRefresh {
        const json = this.toJSON();
        let result = new TokenRefresh();
        result.init(json);
        return result;
    }
}

export interface ITokenRefresh {
    refresh: string;
    access?: string | undefined;
}

/** status */
export enum Status {
    _1 = "1",
    _2 = "2",
    _3 = "3",
    _4 = "4",
    _5 = "5",
    _6 = "6",
    _7 = "7",
    _8 = "8",
    _9 = "9",
}

/** status */
export enum Status2 {
    _1 = "1",
    _2 = "2",
    _3 = "3",
    _4 = "4",
    _5 = "5",
    _6 = "6",
    _7 = "7",
    _8 = "8",
    _9 = "9",
}

export class Anonymous implements IAnonymous {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: AccountBinding[];

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new AccountBinding(item) : <AccountBinding>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AccountBinding.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous>(data, _mappings, Anonymous);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous {
        const json = this.toJSON();
        let result = new Anonymous();
        result.init(json);
        return result;
    }
}

export interface IAnonymous {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IAccountBinding[];
}

export class Anonymous2 implements IAnonymous2 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: CompanyAccountBinding[];

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new CompanyAccountBinding(item) : <CompanyAccountBinding>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CompanyAccountBinding.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous2 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous2>(data, _mappings, Anonymous2);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous2 {
        const json = this.toJSON();
        let result = new Anonymous2();
        result.init(json);
        return result;
    }
}

export interface IAnonymous2 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICompanyAccountBinding[];
}

export class Anonymous3 implements IAnonymous3 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: Transaction[];

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Transaction(item) : <Transaction>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Transaction.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous3 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous3>(data, _mappings, Anonymous3);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous3 {
        const json = this.toJSON();
        let result = new Anonymous3();
        result.init(json);
        return result;
    }
}

export interface IAnonymous3 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ITransaction[];
}

export class Anonymous4 implements IAnonymous4 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: BidPhoto[];

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new BidPhoto(item) : <BidPhoto>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BidPhoto.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous4 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous4>(data, _mappings, Anonymous4);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous4 {
        const json = this.toJSON();
        let result = new Anonymous4();
        result.init(json);
        return result;
    }
}

export interface IAnonymous4 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IBidPhoto[];
}

export class Anonymous5 implements IAnonymous5 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: BidRetrieve[];

    constructor(data?: IAnonymous5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new BidRetrieve(item) : <BidRetrieve>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BidRetrieve.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous5 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous5>(data, _mappings, Anonymous5);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous5 {
        const json = this.toJSON();
        let result = new Anonymous5();
        result.init(json);
        return result;
    }
}

export interface IAnonymous5 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IBidRetrieve[];
}

export class Anonymous6 implements IAnonymous6 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: BidRetrieve[];

    constructor(data?: IAnonymous6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new BidRetrieve(item) : <BidRetrieve>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BidRetrieve.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous6 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous6>(data, _mappings, Anonymous6);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous6 {
        const json = this.toJSON();
        let result = new Anonymous6();
        result.init(json);
        return result;
    }
}

export interface IAnonymous6 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IBidRetrieve[];
}

export class Anonymous7 implements IAnonymous7 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: BidHistory[];

    constructor(data?: IAnonymous7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new BidHistory(item) : <BidHistory>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BidHistory.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous7 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous7>(data, _mappings, Anonymous7);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous7 {
        const json = this.toJSON();
        let result = new Anonymous7();
        result.init(json);
        return result;
    }
}

export interface IAnonymous7 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IBidHistory[];
}

export class Anonymous8 implements IAnonymous8 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: CarRetrieve[];

    constructor(data?: IAnonymous8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new CarRetrieve(item) : <CarRetrieve>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CarRetrieve.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous8 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous8>(data, _mappings, Anonymous8);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous8 {
        const json = this.toJSON();
        let result = new Anonymous8();
        result.init(json);
        return result;
    }
}

export interface IAnonymous8 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICarRetrieve[];
}

export class Anonymous9 implements IAnonymous9 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: CarRetrieve[];

    constructor(data?: IAnonymous9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new CarRetrieve(item) : <CarRetrieve>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CarRetrieve.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous9 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous9>(data, _mappings, Anonymous9);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous9 {
        const json = this.toJSON();
        let result = new Anonymous9();
        result.init(json);
        return result;
    }
}

export interface IAnonymous9 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICarRetrieve[];
}

export class Anonymous10 implements IAnonymous10 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: CarBrand[];

    constructor(data?: IAnonymous10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new CarBrand(item) : <CarBrand>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CarBrand.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous10 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous10>(data, _mappings, Anonymous10);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous10 {
        const json = this.toJSON();
        let result = new Anonymous10();
        result.init(json);
        return result;
    }
}

export interface IAnonymous10 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICarBrand[];
}

export class Anonymous11 implements IAnonymous11 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: CarModel[];

    constructor(data?: IAnonymous11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new CarModel(item) : <CarModel>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CarModel.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous11 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous11>(data, _mappings, Anonymous11);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous11 {
        const json = this.toJSON();
        let result = new Anonymous11();
        result.init(json);
        return result;
    }
}

export interface IAnonymous11 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICarModel[];
}

export class Anonymous12 implements IAnonymous12 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: CarBrandsWithModels[];

    constructor(data?: IAnonymous12) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new CarBrandsWithModels(item) : <CarBrandsWithModels>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CarBrandsWithModels.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous12 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous12>(data, _mappings, Anonymous12);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous12 {
        const json = this.toJSON();
        let result = new Anonymous12();
        result.init(json);
        return result;
    }
}

export interface IAnonymous12 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICarBrandsWithModels[];
}

export class Anonymous13 implements IAnonymous13 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: CarModelRetrieve[];

    constructor(data?: IAnonymous13) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new CarModelRetrieve(item) : <CarModelRetrieve>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CarModelRetrieve.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous13 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous13>(data, _mappings, Anonymous13);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous13 {
        const json = this.toJSON();
        let result = new Anonymous13();
        result.init(json);
        return result;
    }
}

export interface IAnonymous13 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICarModelRetrieve[];
}

export class Anonymous14 implements IAnonymous14 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: City[];

    constructor(data?: IAnonymous14) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new City(item) : <City>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(City.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous14 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous14>(data, _mappings, Anonymous14);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous14 {
        const json = this.toJSON();
        let result = new Anonymous14();
        result.init(json);
        return result;
    }
}

export interface IAnonymous14 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICity[];
}

export class Anonymous15 implements IAnonymous15 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: ServiceType[];

    constructor(data?: IAnonymous15) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ServiceType(item) : <ServiceType>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ServiceType.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous15 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous15>(data, _mappings, Anonymous15);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous15 {
        const json = this.toJSON();
        let result = new Anonymous15();
        result.init(json);
        return result;
    }
}

export interface IAnonymous15 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IServiceType[];
}

export class Anonymous16 implements IAnonymous16 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: ServiceSubtype[];

    constructor(data?: IAnonymous16) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ServiceSubtype(item) : <ServiceSubtype>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ServiceSubtype.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous16 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous16>(data, _mappings, Anonymous16);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous16 {
        const json = this.toJSON();
        let result = new Anonymous16();
        result.init(json);
        return result;
    }
}

export interface IAnonymous16 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IServiceSubtype[];
}

export class Anonymous17 implements IAnonymous17 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: ServiceOption[];

    constructor(data?: IAnonymous17) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ServiceOption(item) : <ServiceOption>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ServiceOption.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous17 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous17>(data, _mappings, Anonymous17);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous17 {
        const json = this.toJSON();
        let result = new Anonymous17();
        result.init(json);
        return result;
    }
}

export interface IAnonymous17 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IServiceOption[];
}

export class Anonymous18 implements IAnonymous18 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: Company[];

    constructor(data?: IAnonymous18) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Company(item) : <Company>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Company.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous18 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous18>(data, _mappings, Anonymous18);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous18 {
        const json = this.toJSON();
        let result = new Anonymous18();
        result.init(json);
        return result;
    }
}

export interface IAnonymous18 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICompany[];
}

export class Anonymous19 implements IAnonymous19 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: GetCustomerCompany[];

    constructor(data?: IAnonymous19) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new GetCustomerCompany(item) : <GetCustomerCompany>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GetCustomerCompany.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous19 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous19>(data, _mappings, Anonymous19);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous19 {
        const json = this.toJSON();
        let result = new Anonymous19();
        result.init(json);
        return result;
    }
}

export interface IAnonymous19 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IGetCustomerCompany[];
}

export class Anonymous20 implements IAnonymous20 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: Company[];

    constructor(data?: IAnonymous20) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Company(item) : <Company>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Company.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous20 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous20>(data, _mappings, Anonymous20);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous20 {
        const json = this.toJSON();
        let result = new Anonymous20();
        result.init(json);
        return result;
    }
}

export interface IAnonymous20 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICompany[];
}

export class Anonymous21 implements IAnonymous21 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: Company[];

    constructor(data?: IAnonymous21) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Company(item) : <Company>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Company.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous21 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous21>(data, _mappings, Anonymous21);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous21 {
        const json = this.toJSON();
        let result = new Anonymous21();
        result.init(json);
        return result;
    }
}

export interface IAnonymous21 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICompany[];
}

export class Anonymous22 implements IAnonymous22 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: Company[];

    constructor(data?: IAnonymous22) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Company(item) : <Company>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Company.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous22 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous22>(data, _mappings, Anonymous22);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous22 {
        const json = this.toJSON();
        let result = new Anonymous22();
        result.init(json);
        return result;
    }
}

export interface IAnonymous22 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ICompany[];
}

export class Anonymous23 implements IAnonymous23 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: GetPerformerCompany[];

    constructor(data?: IAnonymous23) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new GetPerformerCompany(item) : <GetPerformerCompany>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GetPerformerCompany.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous23 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous23>(data, _mappings, Anonymous23);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous23 {
        const json = this.toJSON();
        let result = new Anonymous23();
        result.init(json);
        return result;
    }
}

export interface IAnonymous23 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IGetPerformerCompany[];
}

export class Anonymous24 implements IAnonymous24 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: GetCustomerBranch[];

    constructor(data?: IAnonymous24) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new GetCustomerBranch(item) : <GetCustomerBranch>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GetCustomerBranch.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous24 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous24>(data, _mappings, Anonymous24);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous24 {
        const json = this.toJSON();
        let result = new Anonymous24();
        result.init(json);
        return result;
    }
}

export interface IAnonymous24 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IGetCustomerBranch[];
}

export class Anonymous25 implements IAnonymous25 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: Limit[];

    constructor(data?: IAnonymous25) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new Limit(item) : <Limit>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Limit.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous25 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous25>(data, _mappings, Anonymous25);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous25 {
        const json = this.toJSON();
        let result = new Anonymous25();
        result.init(json);
        return result;
    }
}

export interface IAnonymous25 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: ILimit[];
}

export class Anonymous26 implements IAnonymous26 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: GetPerformerBranch[];

    constructor(data?: IAnonymous26) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new GetPerformerBranch(item) : <GetPerformerBranch>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GetPerformerBranch.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous26 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous26>(data, _mappings, Anonymous26);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous26 {
        const json = this.toJSON();
        let result = new Anonymous26();
        result.init(json);
        return result;
    }
}

export interface IAnonymous26 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IGetPerformerBranch[];
}

export class Anonymous27 implements IAnonymous27 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: GroupPermissions[];

    constructor(data?: IAnonymous27) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new GroupPermissions(item) : <GroupPermissions>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GroupPermissions.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous27 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous27>(data, _mappings, Anonymous27);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous27 {
        const json = this.toJSON();
        let result = new Anonymous27();
        result.init(json);
        return result;
    }
}

export interface IAnonymous27 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IGroupPermissions[];
}

export class Anonymous28 implements IAnonymous28 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: AllWithPrices[];

    constructor(data?: IAnonymous28) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new AllWithPrices(item) : <AllWithPrices>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AllWithPrices.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous28 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous28>(data, _mappings, Anonymous28);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous28 {
        const json = this.toJSON();
        let result = new Anonymous28();
        result.init(json);
        return result;
    }
}

export interface IAnonymous28 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IAllWithPrices[];
}

export class Anonymous29 implements IAnonymous29 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: AllWithPrices[];

    constructor(data?: IAnonymous29) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new AllWithPrices(item) : <AllWithPrices>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AllWithPrices.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous29 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous29>(data, _mappings, Anonymous29);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous29 {
        const json = this.toJSON();
        let result = new Anonymous29();
        result.init(json);
        return result;
    }
}

export interface IAnonymous29 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IAllWithPrices[];
}

export class Anonymous30 implements IAnonymous30 {
    count!: number;
    next?: string | undefined;
    previous?: string | undefined;
    results!: GetHistoryPrice[];

    constructor(data?: IAnonymous30) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new GetHistoryPrice(item) : <GetHistoryPrice>item;
                }
            }
        }
        if (!data) {
            this.results = [];
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.count = _data["count"];
            this.next = _data["next"];
            this.previous = _data["previous"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(GetHistoryPrice.fromJS(item, _mappings));
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Anonymous30 | null {
        data = typeof data === 'object' ? data : {};
        return createInstance<Anonymous30>(data, _mappings, Anonymous30);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["count"] = this.count;
        data["next"] = this.next;
        data["previous"] = this.previous;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }

    clone(): Anonymous30 {
        const json = this.toJSON();
        let result = new Anonymous30();
        result.init(json);
        return result;
    }
}

export interface IAnonymous30 {
    count: number;
    next?: string | undefined;
    previous?: string | undefined;
    results: IGetHistoryPrice[];
}

export enum Company_type {
    КомпанияЗаказчик = "Компания-Заказчик",
    КомпанияПартнер = "Компания-Партнер",
    Физическое_лицо = "Физическое лицо",
    Администратор_системы = "Администратор системы",
}

export enum _PermissionsName {
    Компании = "Компании",
    Управление_филиалами = "Управление филиалами",
    Управление_пользователями = "Управление пользователями",
    Управление_автомобилями = "Управление автомобилями",
    Управление_заявками = "Управление заявками",
    Управление_прайсЛистом = "Управление прайс-листом",
    Управление_лимитами = "Управление лимитами",
    Управление_справочниками = "Управление справочниками",
    Финансовый_блок = "Финансовый блок",
    Расчетный_блок = "Расчетный блок",
    Индивидуальный_расчет = "Индивидуальный расчет",
}

export enum CarModelCar_type {
    A = "A",
    B = "B",
    C = "C",
    D = "D",
    E = "E",
    F = "F",
    S = "S",
    V = "V",
    M = "M",
    J = "J",
    J1 = "J1",
    K = "K",
    P = "P",
    CO1 = "CO1",
    CO2 = "CO2",
    CO3 = "CO3",
}

export enum BidRetrieveStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export enum BidRetrieveTruck_type {
    Эвакуатор = "эвакуатор",
    Манипулятор = "манипулятор",
}

export enum BidRetrieveKeys {
    Нет_секретки = "нет секретки",
    Есть_секретка_и_ключ = "есть секретка и ключ",
    Есть_секретка_и_нет_ключа = "есть секретка и нет ключа",
}

export enum BidCreateKeys {
    Нет_секретки = "нет секретки",
    Есть_секретка_и_ключ = "есть секретка и ключ",
    Есть_секретка_и_нет_ключа = "есть секретка и нет ключа",
}

export enum BidCreateTruck_type {
    Эвакуатор = "эвакуатор",
    Манипулятор = "манипулятор",
}

export enum BidStatusStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
}

export enum CarCreateUpdateRadius {
    R14 = "R14",
    R15 = "R15",
    R16 = "R16",
    R17 = "R17",
    R18 = "R18",
    R19 = "R19",
    R20 = "R20",
    R2123 = "R21-23",
    R15C = "R15C",
    R16C = "R16C",
}

export enum CarRetrieveRadius {
    R14 = "R14",
    R15 = "R15",
    R16 = "R16",
    R17 = "R17",
    R18 = "R18",
    R19 = "R19",
    R20 = "R20",
    R2123 = "R21-23",
    R15C = "R15C",
    R16C = "R16C",
}

export enum CarModelNewBrandCar_type {
    A = "A",
    B = "B",
    C = "C",
    D = "D",
    E = "E",
    F = "F",
    S = "S",
    V = "V",
    M = "M",
    J = "J",
    J1 = "J1",
    K = "K",
    P = "P",
    CO1 = "CO1",
    CO2 = "CO2",
    CO3 = "CO3",
}

export enum CarModelRetrieveCar_type {
    A = "A",
    B = "B",
    C = "C",
    D = "D",
    E = "E",
    F = "F",
    S = "S",
    V = "V",
    M = "M",
    J = "J",
    J1 = "J1",
    K = "K",
    P = "P",
    CO1 = "CO1",
    CO2 = "CO2",
    CO3 = "CO3",
}

export enum AllWithPricesCompany_type {
    КомпанияЗаказчик = "Компания-Заказчик",
    КомпанияПартнер = "Компания-Партнер",
    Физическое_лицо = "Физическое лицо",
    Администратор_системы = "Администратор системы",
}

export enum _TirePositionRadius {
    R14 = "R14",
    R15 = "R15",
    R16 = "R16",
    R17 = "R17",
    R18 = "R18",
    R19 = "R19",
    R20 = "R20",
    R2123 = "R21-23",
    R15C = "R15C",
    R16C = "R16C",
}

export enum _TirePositionCar_type {
    Легковой = "легковой",
    Внедорожный = "внедорожный",
    Коммерческий = "коммерческий",
}

export enum _WashPositionCar_class {
    _1_класс = "1 класс",
    _2_класс = "2 класс",
    _3_класс = "3 класс",
    _4_класс = "4 класс",
    _5_класс = "5 класс",
    _6_класс = "6 класс",
    _7_класс = "7 класс",
    _8_класс = "8 класс",
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;

        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }

        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T | null {
    if (!mappings)
        mappings = [];
    if (!data)
        return null;

    const mappingIndexName = "__mappingIndex";
    if (data[mappingIndexName])
        return <T>mappings[data[mappingIndexName]].target;

    data[mappingIndexName] = mappings.length;

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}
